CCS PCH C Compiler, Version 5.015, 5967               22-nov-20 22:55

               Filename:   C:\Users\lucas\Documents\Faculdade\2-2020\Projeto interdiciplinar\Programação\Projeto\code\main.lst

               ROM used:   1164 bytes (4%)
                           Largest free fragment is 31604
               RAM used:   9 (0%) at main() level
                           20 (1%) worst case
               Stack used: 6 locations
               Stack size: 31

*
0000:  GOTO   0420
.................... //LCD module connections 
.................... #define LCD_RS_PIN PIN_D0 
.................... #define LCD_RW_PIN PIN_D1 
.................... #define LCD_ENABLE_PIN PIN_D2 
.................... #define LCD_DATA4 PIN_D3 
.................... #define LCD_DATA5 PIN_D4 
.................... #define LCD_DATA6 PIN_D5 
.................... #define LCD_DATA7 PIN_D6 
.................... //End LCD module connections 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  DATA 43,61
0006:  DATA 72,72
0008:  DATA 65,67
000A:  DATA 61,6E
000C:  DATA 64,6F
000E:  DATA 20,2E
0010:  DATA 00,00
0012:  DATA 2E,00
0014:  DATA 2E,00
0016:  DATA 2E,00
0018:  DATA 20,20
001A:  DATA 20,20
001C:  DATA 20,20
001E:  DATA 20,20
0020:  DATA 20,20
0022:  DATA 20,20
0024:  DATA 20,20
0026:  DATA 20,20
0028:  DATA 20,20
002A:  DATA 20,20
002C:  DATA 00,00
002E:  DATA 43,6C
0030:  DATA 69,71
0032:  DATA 75,65
0034:  DATA 20,65
0036:  DATA 6D,20
0038:  DATA 69,6E
003A:  DATA 69,63
003C:  DATA 69,61
003E:  DATA 72,00
0040:  DATA 20,20
0042:  DATA 20,20
0044:  DATA 20,20
0046:  DATA 20,20
0048:  DATA 20,20
004A:  DATA 20,20
004C:  DATA 20,20
004E:  DATA 20,20
0050:  DATA 20,20
0052:  DATA 20,20
0054:  DATA 00,00
0056:  DATA 46,65
0058:  DATA 63,68
005A:  DATA 61,20
005C:  DATA 50,6F
005E:  DATA 72,74
0060:  DATA 61,00
0062:  DATA 50,61
0064:  DATA 73,73
0066:  DATA 61,6E
0068:  DATA 64,6F
006A:  DATA 20,70
006C:  DATA 61,67
006E:  DATA 69,6E
0070:  DATA 61,00
0072:  DATA 20,20
0074:  DATA 20,20
0076:  DATA 20,20
0078:  DATA 20,20
007A:  DATA 20,20
007C:  DATA 20,20
007E:  DATA 20,20
0080:  DATA 20,20
0082:  DATA 20,20
0084:  DATA 20,20
0086:  DATA 00,00
0088:  DATA 49,6E
008A:  DATA 69,63
008C:  DATA 69,61
008E:  DATA 64,6F
0090:  DATA 00,00
*
0270:  TBLRD*+
0272:  MOVF   FF5,F
0274:  BZ    028E
0276:  MOVFF  FF6,0A
027A:  MOVFF  FF7,0B
027E:  MOVFF  FF5,0C
0282:  BRA    024E
0284:  MOVFF  0A,FF6
0288:  MOVFF  0B,FF7
028C:  BRA    0270
028E:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOMCLR NOBROWNOUT NOLVP INTRC_IO  
.................... #device ADC = 10 
.................... #use delay(clock = 8000000) 
*
011C:  CLRF   FEA
011E:  MOVLW  0B
0120:  MOVWF  FE9
0122:  MOVF   FEF,W
0124:  BZ    0140
0126:  MOVLW  02
0128:  MOVWF  01
012A:  CLRF   00
012C:  DECFSZ 00,F
012E:  BRA    012C
0130:  DECFSZ 01,F
0132:  BRA    012A
0134:  MOVLW  97
0136:  MOVWF  00
0138:  DECFSZ 00,F
013A:  BRA    0138
013C:  DECFSZ FEF,F
013E:  BRA    0126
0140:  RETURN 0
.................... #use fast_io(B) 
.................... #use fast_io(D) 
.................... #use fast_io(C) 
.................... #use I2C(master, sda=PIN_b0, scl=PIN_b1, ADDRESS = 0X01, FAST = 100000, STREAM = I2C_LCD) 
*
0092:  MOVLW  08
0094:  MOVWF  01
0096:  BRA    0098
0098:  BCF    F8A.1
009A:  BCF    F93.1
009C:  BRA    009E
009E:  NOP   
00A0:  RLCF   13,F
00A2:  BCF    F8A.0
00A4:  BTFSC  FD8.0
00A6:  BSF    F93.0
00A8:  BTFSS  FD8.0
00AA:  BCF    F93.0
00AC:  BSF    F93.1
00AE:  BTFSS  F81.1
00B0:  BRA    00AE
00B2:  DECFSZ 01,F
00B4:  BRA    0096
00B6:  BRA    00B8
00B8:  BCF    F8A.1
00BA:  BCF    F93.1
00BC:  NOP   
00BE:  BSF    F93.0
00C0:  BRA    00C2
00C2:  NOP   
00C4:  BRA    00C6
00C6:  NOP   
00C8:  BSF    F93.1
00CA:  BTFSS  F81.1
00CC:  BRA    00CA
00CE:  CLRF   01
00D0:  BRA    00D2
00D2:  NOP   
00D4:  BTFSC  F81.0
00D6:  BSF    01.0
00D8:  BCF    F8A.1
00DA:  BCF    F93.1
00DC:  BCF    F8A.0
00DE:  BCF    F93.0
00E0:  RETURN 0
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <functions.h> //Biblioteca auxiliar com todas as funções de comando 
.................... #include <I2C_LCD.c> //Biblioteca de controle do Display por I2C 
.................... // CCS C driver code for I2C LCDs (HD44780 compliant controllers) 
.................... // https://simple-circuit.com/ 
....................   
.................... #define LCD_BACKLIGHT          0x08 
.................... #define LCD_NOBACKLIGHT        0x00 
.................... #define LCD_FIRST_ROW          0x80 
.................... #define LCD_SECOND_ROW         0xC0 
.................... #define LCD_THIRD_ROW          0x94 
.................... #define LCD_FOURTH_ROW         0xD4 
.................... #define LCD_CLEAR              0x01 
.................... #define LCD_RETURN_HOME        0x02 
.................... #define LCD_ENTRY_MODE_SET     0x04 
.................... #define LCD_CURSOR_OFF         0x0C 
.................... #define LCD_UNDERLINE_ON       0x0E 
.................... #define LCD_BLINK_CURSOR_ON    0x0F 
.................... #define LCD_MOVE_CURSOR_LEFT   0x10 
.................... #define LCD_MOVE_CURSOR_RIGHT  0x14 
.................... #define LCD_TURN_ON            0x0C 
.................... #define LCD_TURN_OFF           0x08 
.................... #define LCD_SHIFT_LEFT         0x18 
.................... #define LCD_SHIFT_RIGHT        0x1E 
....................   
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................   
....................   
.................... int1 RS; 
.................... unsigned int8 i2c_addr, backlight_val = LCD_BACKLIGHT; 
....................   
.................... void LCD_Write_Nibble(unsigned int8 n); 
.................... void LCD_Cmd(unsigned int8 Command); 
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row); 
.................... void LCD_Out(unsigned int8 LCD_Char); 
.................... void LCD_Begin(unsigned int8 _i2c_addr); 
.................... void Backlight(); 
.................... void noBacklight(); 
.................... void Expander_Write(unsigned int8 value); 
....................   
.................... void LCD_Write_Nibble(unsigned int8 n) { 
....................   n |= RS; 
*
0142:  MOVLW  00
0144:  BTFSC  06.0
0146:  MOVLW  01
0148:  IORWF  0F,F
....................   Expander_Write(n); 
014A:  MOVFF  0F,11
014E:  RCALL  00E2
....................   Expander_Write(n | 0x04); 
0150:  MOVF   0F,W
0152:  IORLW  04
0154:  MOVWF  10
0156:  MOVWF  11
0158:  RCALL  00E2
....................   delay_us(1); 
015A:  BRA    015C
....................   Expander_Write(n & 0xFB); 
015C:  MOVF   0F,W
015E:  ANDLW  FB
0160:  MOVWF  10
0162:  MOVWF  11
0164:  RCALL  00E2
....................   delay_us(50); 
0166:  MOVLW  20
0168:  MOVWF  00
016A:  DECFSZ 00,F
016C:  BRA    016A
016E:  BRA    0170
0170:  NOP   
0172:  RETURN 0
.................... } 
....................   
.................... void LCD_Cmd(unsigned int8 Command) { 
....................   RS = 0; 
0174:  BCF    06.0
....................   LCD_Write_Nibble(Command & 0xF0); 
0176:  MOVF   0D,W
0178:  ANDLW  F0
017A:  MOVWF  0E
017C:  MOVWF  0F
017E:  RCALL  0142
....................   LCD_Write_Nibble((Command << 4) & 0xF0); 
0180:  SWAPF  0D,W
0182:  MOVWF  00
0184:  MOVLW  F0
0186:  ANDWF  00,F
0188:  MOVF   00,W
018A:  ANDLW  F0
018C:  MOVWF  0E
018E:  MOVWF  0F
0190:  RCALL  0142
0192:  RETURN 0
.................... } 
....................   
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row) { 
....................   switch(row) { 
*
0206:  MOVF   0B,W
0208:  XORLW  02
020A:  BZ    0216
020C:  XORLW  01
020E:  BZ    0224
0210:  XORLW  07
0212:  BZ    0232
0214:  BRA    0240
....................     case 2: 
....................       LCD_Cmd(0xC0 + col-1); 
0216:  MOVLW  C0
0218:  ADDWF  0A,W
021A:  ADDLW  FF
021C:  MOVWF  0C
021E:  MOVWF  0D
0220:  RCALL  0174
....................       break; 
0222:  BRA    024C
....................     case 3: 
....................       LCD_Cmd(0x94 + col-1); 
0224:  MOVLW  94
0226:  ADDWF  0A,W
0228:  ADDLW  FF
022A:  MOVWF  0C
022C:  MOVWF  0D
022E:  RCALL  0174
....................       break; 
0230:  BRA    024C
....................     case 4: 
....................       LCD_Cmd(0xD4 + col-1); 
0232:  MOVLW  D4
0234:  ADDWF  0A,W
0236:  ADDLW  FF
0238:  MOVWF  0C
023A:  MOVWF  0D
023C:  RCALL  0174
....................     break; 
023E:  BRA    024C
....................     default:      // case 1: 
....................       LCD_Cmd(0x80 + col-1); 
0240:  MOVLW  80
0242:  ADDWF  0A,W
0244:  ADDLW  FF
0246:  MOVWF  0C
0248:  MOVWF  0D
024A:  RCALL  0174
....................   } 
024C:  RETURN 0
.................... } 
....................   
.................... void LCD_Out(unsigned int8 LCD_Char){ 
....................   RS = 1; 
024E:  BSF    06.0
....................   LCD_Write_Nibble(LCD_Char & 0xF0); 
0250:  MOVF   0C,W
0252:  ANDLW  F0
0254:  MOVWF  0D
0256:  MOVWF  0F
0258:  RCALL  0142
....................   LCD_Write_Nibble((LCD_Char << 4) & 0xF0); 
025A:  SWAPF  0C,W
025C:  MOVWF  00
025E:  MOVLW  F0
0260:  ANDWF  00,F
0262:  MOVF   00,W
0264:  ANDLW  F0
0266:  MOVWF  0D
0268:  MOVWF  0F
026A:  RCALL  0142
026C:  GOTO   0284 (RETURN)
.................... } 
....................   
.................... void LCD_Begin(unsigned int8 _i2c_addr) { 
....................   i2c_addr = _i2c_addr; 
*
0194:  MOVFF  09,07
....................   Expander_Write(0); 
0198:  CLRF   11
019A:  RCALL  00E2
....................   delay_ms(40); 
019C:  MOVLW  28
019E:  MOVWF  0B
01A0:  RCALL  011C
....................   LCD_Cmd(3); 
01A2:  MOVLW  03
01A4:  MOVWF  0D
01A6:  RCALL  0174
....................   delay_ms(5); 
01A8:  MOVLW  05
01AA:  MOVWF  0B
01AC:  RCALL  011C
....................   LCD_Cmd(3); 
01AE:  MOVLW  03
01B0:  MOVWF  0D
01B2:  RCALL  0174
....................   delay_ms(5); 
01B4:  MOVLW  05
01B6:  MOVWF  0B
01B8:  RCALL  011C
....................   LCD_Cmd(3); 
01BA:  MOVLW  03
01BC:  MOVWF  0D
01BE:  RCALL  0174
....................   delay_ms(5); 
01C0:  MOVLW  05
01C2:  MOVWF  0B
01C4:  RCALL  011C
....................   LCD_Cmd(LCD_RETURN_HOME); 
01C6:  MOVLW  02
01C8:  MOVWF  0D
01CA:  RCALL  0174
....................   delay_ms(5); 
01CC:  MOVLW  05
01CE:  MOVWF  0B
01D0:  RCALL  011C
....................   LCD_Cmd(0x20 | (LCD_TYPE << 2)); 
01D2:  MOVLW  28
01D4:  MOVWF  0D
01D6:  RCALL  0174
....................   delay_ms(50); 
01D8:  MOVLW  32
01DA:  MOVWF  0B
01DC:  RCALL  011C
....................   LCD_Cmd(LCD_TURN_ON); 
01DE:  MOVLW  0C
01E0:  MOVWF  0D
01E2:  RCALL  0174
....................   delay_ms(50); 
01E4:  MOVLW  32
01E6:  MOVWF  0B
01E8:  RCALL  011C
....................   LCD_Cmd(LCD_CLEAR); 
01EA:  MOVLW  01
01EC:  MOVWF  0D
01EE:  RCALL  0174
....................   delay_ms(50); 
01F0:  MOVLW  32
01F2:  MOVWF  0B
01F4:  RCALL  011C
....................   LCD_Cmd(LCD_ENTRY_MODE_SET | LCD_RETURN_HOME); 
01F6:  MOVLW  06
01F8:  MOVWF  0D
01FA:  RCALL  0174
....................   delay_ms(50); 
01FC:  MOVLW  32
01FE:  MOVWF  0B
0200:  RCALL  011C
0202:  GOTO   0452 (RETURN)
.................... } 
....................   
.................... void Backlight() { 
....................   backlight_val = LCD_BACKLIGHT; 
....................   Expander_Write(0); 
.................... } 
....................   
.................... void noBacklight() { 
....................   backlight_val = LCD_NOBACKLIGHT; 
....................   Expander_Write(0); 
.................... } 
....................   
.................... void Expander_Write(unsigned int8 value) { 
....................   I2C_Start(I2C_LCD); 
*
00E2:  BSF    F93.0
00E4:  BRA    00E6
00E6:  BSF    F93.1
00E8:  BRA    00EA
00EA:  NOP   
00EC:  BCF    F8A.0
00EE:  BCF    F93.0
00F0:  BRA    00F2
00F2:  BCF    F8A.1
00F4:  BCF    F93.1
....................   I2C_Write(I2C_LCD, i2c_addr); 
00F6:  MOVFF  07,13
00FA:  RCALL  0092
....................   I2C_Write(I2C_LCD, value | backlight_val); 
00FC:  MOVF   11,W
00FE:  IORWF  08,W
0100:  MOVWF  12
0102:  MOVWF  13
0104:  RCALL  0092
....................   I2C_Stop(I2C_LCD); 
0106:  BCF    F93.0
0108:  NOP   
010A:  BSF    F93.1
010C:  BTFSS  F81.1
010E:  BRA    010C
0110:  BRA    0112
0112:  BRA    0114
0114:  NOP   
0116:  BSF    F93.0
0118:  BRA    011A
011A:  RETURN 0
.................... } 
....................  
.................... //Função para iniciar o display 
.................... void Start(){    
....................    //LCD_Goto(coluna, linha);         
....................    LCD_Goto(2, 2);                          
*
0290:  MOVLW  02
0292:  MOVWF  0A
0294:  MOVWF  0B
0296:  RCALL  0206
....................    LCD_Out("Carregando ."); 
0298:  MOVLW  04
029A:  MOVWF  FF6
029C:  MOVLW  00
029E:  MOVWF  FF7
02A0:  RCALL  0270
....................    delay_ms(300); 
02A2:  MOVLW  02
02A4:  MOVWF  09
02A6:  MOVLW  96
02A8:  MOVWF  0B
02AA:  RCALL  011C
02AC:  DECFSZ 09,F
02AE:  BRA    02A6
....................    LCD_Goto(14, 2); 
02B0:  MOVLW  0E
02B2:  MOVWF  0A
02B4:  MOVLW  02
02B6:  MOVWF  0B
02B8:  RCALL  0206
....................    LCD_Out(".");    
02BA:  MOVLW  12
02BC:  MOVWF  FF6
02BE:  MOVLW  00
02C0:  MOVWF  FF7
02C2:  RCALL  0270
....................    delay_ms(300); 
02C4:  MOVLW  02
02C6:  MOVWF  09
02C8:  MOVLW  96
02CA:  MOVWF  0B
02CC:  RCALL  011C
02CE:  DECFSZ 09,F
02D0:  BRA    02C8
....................    LCD_Goto(15, 2); 
02D2:  MOVLW  0F
02D4:  MOVWF  0A
02D6:  MOVLW  02
02D8:  MOVWF  0B
02DA:  RCALL  0206
....................    LCD_Out("."); 
02DC:  MOVLW  14
02DE:  MOVWF  FF6
02E0:  MOVLW  00
02E2:  MOVWF  FF7
02E4:  RCALL  0270
....................    delay_ms(300); 
02E6:  MOVLW  02
02E8:  MOVWF  09
02EA:  MOVLW  96
02EC:  MOVWF  0B
02EE:  RCALL  011C
02F0:  DECFSZ 09,F
02F2:  BRA    02EA
....................    LCD_Goto(16, 2); 
02F4:  MOVLW  10
02F6:  MOVWF  0A
02F8:  MOVLW  02
02FA:  MOVWF  0B
02FC:  RCALL  0206
....................    LCD_Out("."); 
02FE:  MOVLW  16
0300:  MOVWF  FF6
0302:  MOVLW  00
0304:  MOVWF  FF7
0306:  RCALL  0270
....................    delay_ms(300); 
0308:  MOVLW  02
030A:  MOVWF  09
030C:  MOVLW  96
030E:  MOVWF  0B
0310:  RCALL  011C
0312:  DECFSZ 09,F
0314:  BRA    030C
....................    LCD_Goto(1, 2); 
0316:  MOVLW  01
0318:  MOVWF  0A
031A:  MOVLW  02
031C:  MOVWF  0B
031E:  RCALL  0206
....................    LCD_Out("                    ");                //Limpara o display    
0320:  MOVLW  18
0322:  MOVWF  FF6
0324:  MOVLW  00
0326:  MOVWF  FF7
0328:  RCALL  0270
....................    LCD_Goto(2, 2);                                // Go to column 2 row 3 
032A:  MOVLW  02
032C:  MOVWF  0A
032E:  MOVWF  0B
0330:  RCALL  0206
....................    LCD_Out("Clique em iniciar");  
0332:  MOVLW  2E
0334:  MOVWF  FF6
0336:  MOVLW  00
0338:  MOVWF  FF7
033A:  RCALL  0270
033C:  GOTO   0454 (RETURN)
.................... } 
....................  
.................... void CloseDoor(){ 
....................    LCD_Goto(2,2); 
....................    LCD_Out("                    ");                //Limpara o display    
....................    LCD_Goto(2,2); 
....................    LCD_Out("Fecha Porta"); 
.................... } 
....................  
.................... // Função de constrole do andar das lâmpadas ========================================== 
.................... void Lamps(){                                       
....................    unsigned int8 speed_ = 2000;                    //Velocidade dos motores 
....................     
....................    for(;;){                                        //Função para mover as lampadas 
....................       if(input(pin_B7)){                           //Teste para saber se está no final. Se não estiver ela irá para o ponto inicial          
....................          for(int i=0; i<3; i++){                   //irá para o meio da pagina para começar a esterilização             
....................             output_c(0b00000101); 
....................             delay_ms(speed_); 
....................             output_c(0b00000110); 
....................             delay_ms(speed_); 
....................             output_c(0b00010010); 
....................             delay_ms(speed_); 
....................             output_c(0b00010001); 
....................             delay_ms(speed_);         
....................          } 
....................          delay_ms(2000);                         //Tempo de espera de 40 segundos para esterelização   
....................          for(;;){                                //Função que retornará as lampadas para o estágio inicial             
....................             output_c(0b00000110); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00000101); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010001); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010010); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................          }    
....................          break; 
....................       }else{                                    //Caso não esteja na posição inicial essa função irá levar até la                
....................          for(;;){                   
....................             output_c(0b00000110); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break;            //Teste se chegou na posição inicial 
....................             output_c(0b00000101); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010001); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010010); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................          } 
....................       } 
....................    }    
....................    delay_ms(2000);                              //Tempo de aguardo até passar as páginas 
.................... } 
....................  
.................... //Função que irá passar as páginas =============================================================== 
.................... void PassadorPag(){ 
0340:  MOVLW  E8
0342:  MOVWF  09
....................    unsigned int8 speed_ = 1000;           //Velocidade dos motores 
....................    LCD_Cmd(LCD_CLEAR);                          // Limpa o Display;         
0344:  MOVLW  01
0346:  MOVWF  0D
0348:  RCALL  0174
....................    LCD_Goto(2, 2);   
034A:  MOVLW  02
034C:  MOVWF  0A
034E:  MOVWF  0B
0350:  RCALL  0206
....................    LCD_Out("Passando pagina");  
0352:  MOVLW  62
0354:  MOVWF  FF6
0356:  MOVLW  00
0358:  MOVWF  FF7
035A:  RCALL  0270
....................    for(;;){                               //Haste principal irá para a frente até encostar no livro 
....................       output_a(0b00000110); 
035C:  CLRF   F92
035E:  MOVLW  06
0360:  MOVWF  F89
....................       delay_ms(speed_); 
0362:  MOVFF  09,0B
0366:  RCALL  011C
....................       if(input(pin_B3)) break;            //Teste se encostou no livro 
0368:  BTFSC  F81.3
036A:  BRA    039E
....................       output_a(0b00000101); 
036C:  CLRF   F92
036E:  MOVLW  05
0370:  MOVWF  F89
....................       delay_ms(speed_); 
0372:  MOVFF  09,0B
0376:  RCALL  011C
....................       if(input(pin_B3)) break; 
0378:  BTFSC  F81.3
037A:  BRA    039E
....................       output_a(0b00001001); 
037C:  CLRF   F92
037E:  MOVLW  09
0380:  MOVWF  F89
....................       delay_ms(speed_); 
0382:  MOVFF  09,0B
0386:  RCALL  011C
....................       if(input(pin_B3)) break; 
0388:  BTFSC  F81.3
038A:  BRA    039E
....................       output_a(0b00001010); 
038C:  CLRF   F92
038E:  MOVLW  0A
0390:  MOVWF  F89
....................       delay_ms(speed_); 
0392:  MOVFF  09,0B
0396:  RCALL  011C
....................       if(input(pin_B3)) break; 
0398:  BTFSC  F81.3
039A:  BRA    039E
039C:  BRA    035C
....................    } 
....................    delay_ms(500); 
039E:  MOVLW  02
03A0:  MOVWF  0A
03A2:  MOVLW  FA
03A4:  MOVWF  0B
03A6:  RCALL  011C
03A8:  DECFSZ 0A,F
03AA:  BRA    03A2
....................    output_high(pin_B2);                    //Liga o FAN para segurar a página 
03AC:  BSF    F8A.2
....................    delay_ms(1000);                        //Depois que tiver encostador irá parar e esperar até sugar a página 
03AE:  MOVLW  04
03B0:  MOVWF  0A
03B2:  MOVLW  FA
03B4:  MOVWF  0B
03B6:  RCALL  011C
03B8:  DECFSZ 0A,F
03BA:  BRA    03B2
....................    for(;;){                               //Irá passar a pagina até encostar do outro lado 
....................       output_a(0b00000101); 
03BC:  CLRF   F92
03BE:  MOVLW  05
03C0:  MOVWF  F89
....................       delay_ms(speed_); 
03C2:  MOVFF  09,0B
03C6:  RCALL  011C
....................       if(input(pin_B4)) break;            //Teste se chegou do outro lado 
03C8:  BTFSC  F81.4
03CA:  BRA    03FE
....................       output_a(0b00000110); 
03CC:  CLRF   F92
03CE:  MOVLW  06
03D0:  MOVWF  F89
....................       delay_ms(speed_); 
03D2:  MOVFF  09,0B
03D6:  RCALL  011C
....................       if(input(pin_B4)) break; 
03D8:  BTFSC  F81.4
03DA:  BRA    03FE
....................       output_a(0b00001010); 
03DC:  CLRF   F92
03DE:  MOVLW  0A
03E0:  MOVWF  F89
....................       delay_ms(speed_); 
03E2:  MOVFF  09,0B
03E6:  RCALL  011C
....................       if(input(pin_B4)) break; 
03E8:  BTFSC  F81.4
03EA:  BRA    03FE
....................       output_a(0b00001001); 
03EC:  CLRF   F92
03EE:  MOVLW  09
03F0:  MOVWF  F89
....................       delay_ms(speed_);        
03F2:  MOVFF  09,0B
03F6:  RCALL  011C
....................       if(input(pin_B4)) break; 
03F8:  BTFSC  F81.4
03FA:  BRA    03FE
03FC:  BRA    03BC
....................    } 
....................    delay_ms(1000);                         
03FE:  MOVLW  04
0400:  MOVWF  0A
0402:  MOVLW  FA
0404:  MOVWF  0B
0406:  RCALL  011C
0408:  DECFSZ 0A,F
040A:  BRA    0402
....................    output_low(pin_B2);                    //Desliga a FAN do Passador 
040C:  BCF    F8A.2
....................    delay_ms(5000);    
040E:  MOVLW  14
0410:  MOVWF  0A
0412:  MOVLW  FA
0414:  MOVWF  0B
0416:  RCALL  011C
0418:  DECFSZ 0A,F
041A:  BRA    0412
041C:  GOTO   0482 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... void main() 
0420:  CLRF   FF8
0422:  BCF    FD0.7
0424:  MOVLW  70
0426:  MOVWF  FD3
0428:  MOVF   FD3,W
042A:  MOVLW  08
042C:  MOVWF  08
042E:  MOVF   FC1,W
0430:  ANDLW  C0
0432:  IORLW  0F
0434:  MOVWF  FC1
0436:  MOVLW  07
0438:  MOVWF  FB4
043A:  CLRF   04
043C:  CLRF   05
.................... { 
....................    output_b(0);     
043E:  CLRF   F8A
....................    output_d(0);  
0440:  CLRF   F8C
....................    output_c(0);  
0442:  CLRF   F8B
....................    set_tris_b(0b1111000); //setando as portas como 1=input || 0=output 
0444:  MOVLW  78
0446:  MOVWF  F93
....................    set_tris_c(0);  
0448:  MOVLW  00
044A:  MOVWF  F94
....................    LCD_Begin(0x4E);  
044C:  MOVLW  4E
044E:  MOVWF  09
0450:  BRA    0194
....................    Start(); 
0452:  BRA    0290
....................    while(TRUE){ 
....................       if(input(pin_B5)){          
0454:  BTFSS  F81.5
0456:  BRA    0482
....................          if(input(pin_B6)){                  
0458:  BTFSS  F81.6
045A:  BRA    0482
....................                LCD_Goto(2,2); 
045C:  MOVLW  02
045E:  MOVWF  0A
0460:  MOVWF  0B
0462:  RCALL  0206
....................                LCD_Out("                    ");                //Limpara o display    
0464:  MOVLW  72
0466:  MOVWF  FF6
0468:  MOVLW  00
046A:  MOVWF  FF7
046C:  RCALL  0270
....................                LCD_Goto(2,2); 
046E:  MOVLW  02
0470:  MOVWF  0A
0472:  MOVWF  0B
0474:  RCALL  0206
....................                LCD_Out("Iniciado"); 
0476:  MOVLW  88
0478:  MOVWF  FF6
047A:  MOVLW  00
047C:  MOVWF  FF7
047E:  RCALL  0270
....................                //Lamps(); 
....................                PassadorPag(); 
0480:  BRA    0340
....................          }else{                                               //Teste para as portas fechadas  
....................                                            
....................          } 
....................       } 
....................       delay_ms(200); 
0482:  MOVLW  C8
0484:  MOVWF  0B
0486:  RCALL  011C
0488:  BRA    0454
....................    } 
.................... } 
....................  
048A:  SLEEP 
....................  

Configuration Fuses:
   Word  1: C83F   PLL12 CPUDIV4 USBDIV INTRC_IO FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
