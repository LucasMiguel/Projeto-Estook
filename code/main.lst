CCS PCH C Compiler, Version 5.015, 5967               27-nov-20 20:45

               Filename:   C:\Users\lucas\Documents\Faculdade\2-2020\Projeto interdiciplinar\Programação\Projeto\code\main.lst

               ROM used:   2500 bytes (15%)
                           Largest free fragment is 13884
               RAM used:   25 (3%) at main() level
                           38 (5%) worst case
               Stack used: 6 locations
               Stack size: 31

*
0000:  GOTO   0868
.................... #include <18F6490.h> 
.................... //////////// Standard Header file for the PIC18F6490 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F6490 
0004:  CLRF   FF7
0006:  ADDLW  14
0008:  MOVWF  FF6
000A:  MOVLW  00
000C:  ADDWFC FF7,F
000E:  TBLRD*+
0010:  MOVF   FF5,W
0012:  RETURN 0
0014:  DATA 31,32
0016:  DATA 33,34
0018:  DATA 35,36
001A:  DATA 37,38
001C:  DATA 39,2A
001E:  DATA 30,23
0020:  DATA 43,61
0022:  DATA 72,72
0024:  DATA 65,67
0026:  DATA 61,6E
0028:  DATA 64,6F
002A:  DATA 20,2E
002C:  DATA 00,00
002E:  DATA 2E,00
0030:  DATA 2E,00
0032:  DATA 2E,00
0034:  DATA 46,65
0036:  DATA 63,68
0038:  DATA 61,20
003A:  DATA 50,6F
003C:  DATA 72,74
003E:  DATA 61,20
0040:  DATA 21,21
0042:  DATA 00,00
0044:  DATA 51,74
0046:  DATA 73,20
0048:  DATA 70,61
004A:  DATA 67,69
004C:  DATA 6E,61
004E:  DATA 73,3A
0050:  DATA 00,00
0052:  DATA 23,00
0054:  DATA 49,6E
0056:  DATA 69,63
0058:  DATA 69,61
005A:  DATA 64,6F
005C:  DATA 21,21
005E:  DATA 00,00
0060:  DATA 50,61
0062:  DATA 67,2E
0064:  DATA 20,72
0066:  DATA 65,73
0068:  DATA 74,61
006A:  DATA 6E,74
006C:  DATA 65,73
006E:  DATA 3A,00
*
0250:  TBLRD*+
0252:  MOVF   FF5,F
0254:  BZ    026E
0256:  MOVFF  FF6,18
025A:  MOVFF  FF7,19
025E:  MOVFF  FF5,1F
0262:  RCALL  0230
0264:  MOVFF  18,FF6
0268:  MOVFF  19,FF7
026C:  BRA    0250
026E:  RETURN 0
*
03AC:  CLRF   00
03AE:  CLRF   01
03B0:  MOVF   1F,W
03B2:  BCF    FD8.0
03B4:  BTFSC  20.0
03B6:  ADDWF  00,F
03B8:  RRCF   00,F
03BA:  RRCF   01,F
03BC:  BTFSC  20.1
03BE:  ADDWF  00,F
03C0:  RRCF   00,F
03C2:  RRCF   01,F
03C4:  BTFSC  20.2
03C6:  ADDWF  00,F
03C8:  RRCF   00,F
03CA:  RRCF   01,F
03CC:  BTFSC  20.3
03CE:  ADDWF  00,F
03D0:  RRCF   00,F
03D2:  RRCF   01,F
03D4:  BTFSC  20.4
03D6:  ADDWF  00,F
03D8:  RRCF   00,F
03DA:  RRCF   01,F
03DC:  BTFSC  20.5
03DE:  ADDWF  00,F
03E0:  RRCF   00,F
03E2:  RRCF   01,F
03E4:  BTFSC  20.6
03E6:  ADDWF  00,F
03E8:  RRCF   00,F
03EA:  RRCF   01,F
03EC:  BTFSC  20.7
03EE:  ADDWF  00,F
03F0:  RRCF   00,F
03F2:  RRCF   01,F
03F4:  GOTO   04D0 (RETURN)
*
0594:  MOVF   20,W
0596:  CLRF   01
0598:  SUBWF  1F,W
059A:  BC    05A2
059C:  MOVFF  1F,00
05A0:  BRA    05BA
05A2:  CLRF   00
05A4:  MOVLW  08
05A6:  MOVWF  21
05A8:  RLCF   1F,F
05AA:  RLCF   00,F
05AC:  MOVF   20,W
05AE:  SUBWF  00,W
05B0:  BTFSC  FD8.0
05B2:  MOVWF  00
05B4:  RLCF   01,F
05B6:  DECFSZ 21,F
05B8:  BRA    05A8
05BA:  RETURN 0
05BC:  MOVLW  20
05BE:  BTFSS  1A.4
05C0:  MOVLW  30
05C2:  MOVWF  1B
05C4:  MOVFF  19,00
05C8:  BTFSS  19.7
05CA:  BRA    05DC
05CC:  COMF   00,F
05CE:  INCF   00,F
05D0:  MOVFF  00,19
05D4:  MOVLW  2D
05D6:  MOVWF  1B
05D8:  BSF    1A.7
05DA:  BSF    1A.0
05DC:  MOVF   01,W
05DE:  MOVFF  19,1F
05E2:  MOVLW  64
05E4:  MOVWF  20
05E6:  RCALL  0594
05E8:  MOVFF  00,19
05EC:  MOVLW  30
05EE:  ADDWF  01,W
05F0:  MOVWF  1C
05F2:  MOVFF  19,1F
05F6:  MOVLW  0A
05F8:  MOVWF  20
05FA:  RCALL  0594
05FC:  MOVLW  30
05FE:  ADDWF  00,W
0600:  MOVWF  1E
0602:  MOVLW  30
0604:  ADDWF  01,W
0606:  MOVWF  1D
0608:  MOVFF  1B,00
060C:  MOVLW  30
060E:  SUBWF  1C,W
0610:  BZ    061A
0612:  BSF    1A.1
0614:  BTFSC  1A.7
0616:  BSF    1A.2
0618:  BRA    063E
061A:  MOVFF  1B,1C
061E:  MOVLW  20
0620:  MOVWF  1B
0622:  MOVLW  30
0624:  SUBWF  1D,W
0626:  BZ    0630
0628:  BSF    1A.0
062A:  BTFSC  1A.7
062C:  BSF    1A.1
062E:  BRA    063E
0630:  BTFSS  FD8.2
0632:  BSF    1A.0
0634:  BNZ   063E
0636:  MOVFF  1C,1D
063A:  MOVLW  20
063C:  MOVWF  1C
063E:  BTFSC  1A.2
0640:  BRA    064C
0642:  BTFSC  1A.1
0644:  BRA    0652
0646:  BTFSC  1A.0
0648:  BRA    0658
064A:  BRA    065E
064C:  MOVFF  1B,1F
0650:  RCALL  0230
0652:  MOVFF  1C,1F
0656:  RCALL  0230
0658:  MOVFF  1D,1F
065C:  RCALL  0230
065E:  MOVFF  1E,1F
0662:  RCALL  0230
0664:  GOTO   09B4 (RETURN)
....................  
.................... #list 
....................  
.................... #fuses NOMCLR NOBROWNOUT INTRC_IO  
.................... #device ADC = 10 
.................... #use delay(clock = 8000000) 
*
00FA:  CLRF   FEA
00FC:  MOVLW  1B
00FE:  MOVWF  FE9
0100:  MOVF   FEF,W
0102:  BZ    011E
0104:  MOVLW  02
0106:  MOVWF  01
0108:  CLRF   00
010A:  DECFSZ 00,F
010C:  BRA    010A
010E:  DECFSZ 01,F
0110:  BRA    0108
0112:  MOVLW  97
0114:  MOVWF  00
0116:  DECFSZ 00,F
0118:  BRA    0116
011A:  DECFSZ FEF,F
011C:  BRA    0104
011E:  RETURN 0
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use I2C(master, sda=PIN_C4, scl=PIN_C3, ADDRESS = 0X01, FAST =100000, STREAM = I2C_LCD) 
*
0070:  MOVLW  08
0072:  MOVWF  01
0074:  BRA    0076
0076:  BCF    F8B.3
0078:  BCF    F94.3
007A:  BRA    007C
007C:  NOP   
007E:  RLCF   25,F
0080:  BCF    F8B.4
0082:  BTFSC  FD8.0
0084:  BSF    F94.4
0086:  BTFSS  FD8.0
0088:  BCF    F94.4
008A:  BSF    F94.3
008C:  BTFSS  F82.3
008E:  BRA    008C
0090:  DECFSZ 01,F
0092:  BRA    0074
0094:  BRA    0096
0096:  BCF    F8B.3
0098:  BCF    F94.3
009A:  NOP   
009C:  BSF    F94.4
009E:  BRA    00A0
00A0:  NOP   
00A2:  BRA    00A4
00A4:  NOP   
00A6:  BSF    F94.3
00A8:  BTFSS  F82.3
00AA:  BRA    00A8
00AC:  CLRF   01
00AE:  BRA    00B0
00B0:  NOP   
00B2:  BTFSC  F82.4
00B4:  BSF    01.0
00B6:  BCF    F8B.3
00B8:  BCF    F94.3
00BA:  BCF    F8B.4
00BC:  BCF    F94.4
00BE:  RETURN 0
.................... #use rs232(baud=9600, xmit= PIN_C6, rcv= PIN_C7, bits=8) 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
03F8:  CLRF   1D
....................    sign = 0; 
03FA:  CLRF   1B
....................    base = 10; 
03FC:  MOVLW  0A
03FE:  MOVWF  1C
....................    result = 0; 
0400:  CLRF   1A
....................  
....................    if (!s) 
0402:  MOVF   18,W
0404:  IORWF  19,W
0406:  BNZ   040E
....................       return 0; 
0408:  MOVLW  00
040A:  MOVWF  01
040C:  BRA    0590
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
040E:  MOVF   1D,W
0410:  INCF   1D,F
0412:  CLRF   03
0414:  ADDWF  18,W
0416:  MOVWF  FE9
0418:  MOVF   19,W
041A:  ADDWFC 03,W
041C:  MOVWF  FEA
041E:  MOVFF  FEF,1E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0422:  MOVF   1E,W
0424:  SUBLW  2D
0426:  BNZ   0442
....................    { 
....................       sign = 1;         // Set the sign to negative 
0428:  MOVLW  01
042A:  MOVWF  1B
....................       c = s[index++]; 
042C:  MOVF   1D,W
042E:  INCF   1D,F
0430:  CLRF   03
0432:  ADDWF  18,W
0434:  MOVWF  FE9
0436:  MOVF   19,W
0438:  ADDWFC 03,W
043A:  MOVWF  FEA
043C:  MOVFF  FEF,1E
....................    } 
0440:  BRA    045C
....................    else if (c == '+') 
0442:  MOVF   1E,W
0444:  SUBLW  2B
0446:  BNZ   045C
....................    { 
....................       c = s[index++]; 
0448:  MOVF   1D,W
044A:  INCF   1D,F
044C:  CLRF   03
044E:  ADDWF  18,W
0450:  MOVWF  FE9
0452:  MOVF   19,W
0454:  ADDWFC 03,W
0456:  MOVWF  FEA
0458:  MOVFF  FEF,1E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
045C:  MOVF   1E,W
045E:  SUBLW  2F
0460:  BTFSC  FD8.0
0462:  BRA    0580
0464:  MOVF   1E,W
0466:  SUBLW  39
0468:  BTFSS  FD8.0
046A:  BRA    0580
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
046C:  MOVF   1E,W
046E:  SUBLW  30
0470:  BNZ   04B4
0472:  CLRF   03
0474:  MOVF   1D,W
0476:  ADDWF  18,W
0478:  MOVWF  FE9
047A:  MOVF   19,W
047C:  ADDWFC 03,W
047E:  MOVWF  FEA
0480:  MOVF   FEF,W
0482:  SUBLW  78
0484:  BZ    049A
0486:  CLRF   03
0488:  MOVF   1D,W
048A:  ADDWF  18,W
048C:  MOVWF  FE9
048E:  MOVF   19,W
0490:  ADDWFC 03,W
0492:  MOVWF  FEA
0494:  MOVF   FEF,W
0496:  SUBLW  58
0498:  BNZ   04B4
....................       { 
....................          base = 16; 
049A:  MOVLW  10
049C:  MOVWF  1C
....................          index++; 
049E:  INCF   1D,F
....................          c = s[index++]; 
04A0:  MOVF   1D,W
04A2:  INCF   1D,F
04A4:  CLRF   03
04A6:  ADDWF  18,W
04A8:  MOVWF  FE9
04AA:  MOVF   19,W
04AC:  ADDWFC 03,W
04AE:  MOVWF  FEA
04B0:  MOVFF  FEF,1E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
04B4:  MOVF   1C,W
04B6:  SUBLW  0A
04B8:  BNZ   04F0
....................       { 
....................          while (c >= '0' && c <= '9') 
04BA:  MOVF   1E,W
04BC:  SUBLW  2F
04BE:  BC    04EE
04C0:  MOVF   1E,W
04C2:  SUBLW  39
04C4:  BNC   04EE
....................          { 
....................             result = 10*result + (c - '0'); 
04C6:  MOVLW  0A
04C8:  MOVWF  1F
04CA:  MOVFF  1A,20
04CE:  BRA    03AC
04D0:  MOVLW  30
04D2:  SUBWF  1E,W
04D4:  ADDWF  01,W
04D6:  MOVWF  1A
....................             c = s[index++]; 
04D8:  MOVF   1D,W
04DA:  INCF   1D,F
04DC:  CLRF   03
04DE:  ADDWF  18,W
04E0:  MOVWF  FE9
04E2:  MOVF   19,W
04E4:  ADDWFC 03,W
04E6:  MOVWF  FEA
04E8:  MOVFF  FEF,1E
04EC:  BRA    04BA
....................          } 
....................       } 
04EE:  BRA    0580
....................       else if (base == 16)    // The number is a hexa number 
04F0:  MOVF   1C,W
04F2:  SUBLW  10
04F4:  BNZ   0580
....................       { 
....................          c = toupper(c); 
04F6:  MOVF   1E,W
04F8:  SUBLW  60
04FA:  BC    0508
04FC:  MOVF   1E,W
04FE:  SUBLW  7A
0500:  BNC   0508
0502:  MOVF   1E,W
0504:  ANDLW  DF
0506:  BRA    050A
0508:  MOVF   1E,W
050A:  MOVWF  1E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
050C:  MOVF   1E,W
050E:  SUBLW  2F
0510:  BC    0518
0512:  MOVF   1E,W
0514:  SUBLW  39
0516:  BC    0524
0518:  MOVF   1E,W
051A:  SUBLW  40
051C:  BC    0580
051E:  MOVF   1E,W
0520:  SUBLW  46
0522:  BNC   0580
....................          { 
....................             if (c >= '0' && c <= '9') 
0524:  MOVF   1E,W
0526:  SUBLW  2F
0528:  BC    0542
052A:  MOVF   1E,W
052C:  SUBLW  39
052E:  BNC   0542
....................                result = (result << 4) + (c - '0'); 
0530:  SWAPF  1A,W
0532:  MOVWF  1F
0534:  MOVLW  F0
0536:  ANDWF  1F,F
0538:  MOVLW  30
053A:  SUBWF  1E,W
053C:  ADDWF  1F,W
053E:  MOVWF  1A
0540:  BRA    0554
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0542:  SWAPF  1A,W
0544:  MOVWF  1F
0546:  MOVLW  F0
0548:  ANDWF  1F,F
054A:  MOVLW  41
054C:  SUBWF  1E,W
054E:  ADDLW  0A
0550:  ADDWF  1F,W
0552:  MOVWF  1A
....................  
....................             c = s[index++]; 
0554:  MOVF   1D,W
0556:  INCF   1D,F
0558:  CLRF   03
055A:  ADDWF  18,W
055C:  MOVWF  FE9
055E:  MOVF   19,W
0560:  ADDWFC 03,W
0562:  MOVWF  FEA
0564:  MOVFF  FEF,1E
....................             c = toupper(c); 
0568:  MOVF   1E,W
056A:  SUBLW  60
056C:  BC    057A
056E:  MOVF   1E,W
0570:  SUBLW  7A
0572:  BNC   057A
0574:  MOVF   1E,W
0576:  ANDLW  DF
0578:  BRA    057C
057A:  MOVF   1E,W
057C:  MOVWF  1E
057E:  BRA    050C
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0580:  DECFSZ 1B,W
0582:  BRA    058C
0584:  MOVF   1C,W
0586:  SUBLW  0A
0588:  BNZ   058C
....................        result = -result; 
058A:  NEGF   1A
....................  
....................    return(result); 
058C:  MOVFF  1A,01
0590:  GOTO   094C (RETURN)
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <functions.h> //Biblioteca auxiliar com todas as funções de comando 
.................... #include <I2C_LCD.c> //Biblioteca de controle do Display por I2C 
.................... // CCS C driver code for I2C LCDs (HD44780 compliant controllers) 
.................... // https://simple-circuit.com/ 
....................   
.................... #define LCD_BACKLIGHT          0x08 
.................... #define LCD_NOBACKLIGHT        0x00 
.................... #define LCD_FIRST_ROW          0x80 
.................... #define LCD_SECOND_ROW         0xC0 
.................... #define LCD_THIRD_ROW          0x94 
.................... #define LCD_FOURTH_ROW         0xD4 
.................... #define LCD_CLEAR              0x01 
.................... #define LCD_RETURN_HOME        0x02 
.................... #define LCD_ENTRY_MODE_SET     0x04 
.................... #define LCD_CURSOR_OFF         0x0C 
.................... #define LCD_UNDERLINE_ON       0x0E 
.................... #define LCD_BLINK_CURSOR_ON    0x0F 
.................... #define LCD_MOVE_CURSOR_LEFT   0x10 
.................... #define LCD_MOVE_CURSOR_RIGHT  0x14 
.................... #define LCD_TURN_ON            0x0C 
.................... #define LCD_TURN_OFF           0x08 
.................... #define LCD_SHIFT_LEFT         0x18 
.................... #define LCD_SHIFT_RIGHT        0x1E 
....................   
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................   
....................   
.................... int1 RS; 
.................... unsigned int8 i2c_addr, backlight_val = LCD_BACKLIGHT; 
....................   
.................... void LCD_Write_Nibble(unsigned int8 n); 
.................... void LCD_Cmd(unsigned int8 Command); 
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row); 
.................... void LCD_Out(unsigned int8 LCD_Char); 
.................... void LCD_Begin(unsigned int8 _i2c_addr); 
.................... void Backlight(); 
.................... void noBacklight(); 
.................... void Expander_Write(unsigned int8 value); 
....................   
.................... void LCD_Write_Nibble(unsigned int8 n) { 
....................   n |= RS; 
*
0120:  MOVLW  00
0122:  BTFSC  0A.0
0124:  MOVLW  01
0126:  IORWF  21,F
....................   Expander_Write(n); 
0128:  MOVFF  21,23
012C:  RCALL  00C0
....................   Expander_Write(n | 0x04); 
012E:  MOVF   21,W
0130:  IORLW  04
0132:  MOVWF  22
0134:  MOVWF  23
0136:  RCALL  00C0
....................   delay_us(1); 
0138:  BRA    013A
....................   Expander_Write(n & 0xFB); 
013A:  MOVF   21,W
013C:  ANDLW  FB
013E:  MOVWF  22
0140:  MOVWF  23
0142:  RCALL  00C0
....................   delay_us(50); 
0144:  MOVLW  20
0146:  MOVWF  00
0148:  DECFSZ 00,F
014A:  BRA    0148
014C:  BRA    014E
014E:  NOP   
0150:  RETURN 0
.................... } 
....................   
.................... void LCD_Cmd(unsigned int8 Command) { 
....................   RS = 0; 
0152:  BCF    0A.0
....................   LCD_Write_Nibble(Command & 0xF0); 
0154:  MOVF   1B,W
0156:  ANDLW  F0
0158:  MOVWF  1C
015A:  MOVWF  21
015C:  RCALL  0120
....................   LCD_Write_Nibble((Command << 4) & 0xF0); 
015E:  SWAPF  1B,W
0160:  MOVWF  00
0162:  MOVLW  F0
0164:  ANDWF  00,F
0166:  MOVF   00,W
0168:  ANDLW  F0
016A:  MOVWF  1C
016C:  MOVWF  21
016E:  RCALL  0120
0170:  RETURN 0
.................... } 
....................   
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row) { 
....................   switch(row) { 
*
01E8:  MOVF   19,W
01EA:  XORLW  02
01EC:  BZ    01F8
01EE:  XORLW  01
01F0:  BZ    0206
01F2:  XORLW  07
01F4:  BZ    0214
01F6:  BRA    0222
....................     case 2: 
....................       LCD_Cmd(0xC0 + col-1); 
01F8:  MOVLW  C0
01FA:  ADDWF  18,W
01FC:  ADDLW  FF
01FE:  MOVWF  1A
0200:  MOVWF  1B
0202:  RCALL  0152
....................       break; 
0204:  BRA    022E
....................     case 3: 
....................       LCD_Cmd(0x94 + col-1); 
0206:  MOVLW  94
0208:  ADDWF  18,W
020A:  ADDLW  FF
020C:  MOVWF  1A
020E:  MOVWF  1B
0210:  RCALL  0152
....................       break; 
0212:  BRA    022E
....................     case 4: 
....................       LCD_Cmd(0xD4 + col-1); 
0214:  MOVLW  D4
0216:  ADDWF  18,W
0218:  ADDLW  FF
021A:  MOVWF  1A
021C:  MOVWF  1B
021E:  RCALL  0152
....................     break; 
0220:  BRA    022E
....................     default:      // case 1: 
....................       LCD_Cmd(0x80 + col-1); 
0222:  MOVLW  80
0224:  ADDWF  18,W
0226:  ADDLW  FF
0228:  MOVWF  1A
022A:  MOVWF  1B
022C:  RCALL  0152
....................   } 
022E:  RETURN 0
.................... } 
....................   
.................... void LCD_Out(unsigned int8 LCD_Char){ 
....................   RS = 1; 
0230:  BSF    0A.0
....................   LCD_Write_Nibble(LCD_Char & 0xF0); 
0232:  MOVF   1F,W
0234:  ANDLW  F0
0236:  MOVWF  20
0238:  MOVWF  21
023A:  RCALL  0120
....................   LCD_Write_Nibble((LCD_Char << 4) & 0xF0); 
023C:  SWAPF  1F,W
023E:  MOVWF  00
0240:  MOVLW  F0
0242:  ANDWF  00,F
0244:  MOVF   00,W
0246:  ANDLW  F0
0248:  MOVWF  20
024A:  MOVWF  21
024C:  RCALL  0120
024E:  RETURN 0
.................... } 
....................   
.................... void LCD_Begin(unsigned int8 _i2c_addr) { 
....................   i2c_addr = _i2c_addr; 
*
0172:  MOVFF  18,0B
....................   Expander_Write(0); 
0176:  CLRF   23
0178:  RCALL  00C0
....................   delay_ms(40); 
017A:  MOVLW  28
017C:  MOVWF  1B
017E:  RCALL  00FA
....................   LCD_Cmd(3); 
0180:  MOVLW  03
0182:  MOVWF  1B
0184:  RCALL  0152
....................   delay_ms(5); 
0186:  MOVLW  05
0188:  MOVWF  1B
018A:  RCALL  00FA
....................   LCD_Cmd(3); 
018C:  MOVLW  03
018E:  MOVWF  1B
0190:  RCALL  0152
....................   delay_ms(5); 
0192:  MOVLW  05
0194:  MOVWF  1B
0196:  RCALL  00FA
....................   LCD_Cmd(3); 
0198:  MOVLW  03
019A:  MOVWF  1B
019C:  RCALL  0152
....................   delay_ms(5); 
019E:  MOVLW  05
01A0:  MOVWF  1B
01A2:  RCALL  00FA
....................   LCD_Cmd(LCD_RETURN_HOME); 
01A4:  MOVLW  02
01A6:  MOVWF  1B
01A8:  RCALL  0152
....................   delay_ms(5); 
01AA:  MOVLW  05
01AC:  MOVWF  1B
01AE:  RCALL  00FA
....................   LCD_Cmd(0x20 | (LCD_TYPE << 2)); 
01B0:  MOVLW  28
01B2:  MOVWF  1B
01B4:  RCALL  0152
....................   delay_ms(50); 
01B6:  MOVLW  32
01B8:  MOVWF  1B
01BA:  RCALL  00FA
....................   LCD_Cmd(LCD_TURN_ON); 
01BC:  MOVLW  0C
01BE:  MOVWF  1B
01C0:  RCALL  0152
....................   delay_ms(50); 
01C2:  MOVLW  32
01C4:  MOVWF  1B
01C6:  RCALL  00FA
....................   LCD_Cmd(LCD_CLEAR); 
01C8:  MOVLW  01
01CA:  MOVWF  1B
01CC:  RCALL  0152
....................   delay_ms(50); 
01CE:  MOVLW  32
01D0:  MOVWF  1B
01D2:  RCALL  00FA
....................   LCD_Cmd(LCD_ENTRY_MODE_SET | LCD_RETURN_HOME); 
01D4:  MOVLW  06
01D6:  MOVWF  1B
01D8:  RCALL  0152
....................   delay_ms(50); 
01DA:  MOVLW  32
01DC:  MOVWF  1B
01DE:  RCALL  00FA
01E0:  GOTO   08CC (RETURN)
.................... } 
....................   
.................... void Backlight() { 
....................   backlight_val = LCD_BACKLIGHT; 
....................   Expander_Write(0); 
.................... } 
....................   
.................... void noBacklight() { 
....................   backlight_val = LCD_NOBACKLIGHT; 
....................   Expander_Write(0); 
.................... } 
....................   
.................... void Expander_Write(unsigned int8 value) { 
....................   I2C_Start(I2C_LCD); 
*
00C0:  BSF    F94.4
00C2:  BRA    00C4
00C4:  BSF    F94.3
00C6:  BRA    00C8
00C8:  NOP   
00CA:  BCF    F8B.4
00CC:  BCF    F94.4
00CE:  BRA    00D0
00D0:  BCF    F8B.3
00D2:  BCF    F94.3
....................   I2C_Write(I2C_LCD, i2c_addr); 
00D4:  MOVFF  0B,25
00D8:  RCALL  0070
....................   I2C_Write(I2C_LCD, value | backlight_val); 
00DA:  MOVF   23,W
00DC:  IORWF  0C,W
00DE:  MOVWF  24
00E0:  MOVWF  25
00E2:  RCALL  0070
....................   I2C_Stop(I2C_LCD); 
00E4:  BCF    F94.4
00E6:  NOP   
00E8:  BSF    F94.3
00EA:  BTFSS  F82.3
00EC:  BRA    00EA
00EE:  BRA    00F0
00F0:  BRA    00F2
00F2:  NOP   
00F4:  BSF    F94.4
00F6:  BRA    00F8
00F8:  RETURN 0
.................... } 
....................  
.................... #include <kbd.c>  //Biblioteca do KeyPad 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             KBD.C                                 //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
.................... #if defined use_portb_kbd 
....................    #byte kbd = getenv("SFR:PORTB") 
.................... #else 
....................    #byte kbd = getenv("SFR:PORTD") 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... //Keypad connection:   (for example column 0 is B2) 
.................... //                Bx: 
....................  
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// For the black keypad 
.................... #define COL0 (1 << 5) 
.................... #define COL1 (1 << 6) 
.................... #define COL2 (1 << 7) 
....................  
.................... #define ROW0 (1 << 1) 
.................... #define ROW1 (1 << 2) 
.................... #define ROW2 (1 << 3) 
.................... #define ROW3 (1 << 4) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][3] = {{'1','2','3'}, 
....................                          {'4','5','6'}, 
....................                          {'7','8','9'}, 
....................                          {'*','0','#'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
....................  
.................... void kbd_init() { 
*
01E4:  GOTO   08CE (RETURN)
.................... } 
....................  
.................... char kbd_getc( ) { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
*
02F2:  CLRF   18
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
02F4:  INCF   0D,F
02F6:  MOVF   0D,W
02F8:  SUBLW  21
02FA:  BC    03A0
....................        switch (col) { 
02FC:  MOVF   0F,W
02FE:  BZ    030A
0300:  XORLW  01
0302:  BZ    0312
0304:  XORLW  03
0306:  BZ    031A
0308:  BRA    0320
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
030A:  MOVLW  DE
030C:  MOVWF  F95
....................                     kbd=~COL0&ALL_PINS; 
030E:  MOVWF  F83
....................                     break; 
0310:  BRA    0320
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
0312:  MOVLW  BE
0314:  MOVWF  F95
....................                     kbd=~COL1&ALL_PINS; 
0316:  MOVWF  F83
....................                     break; 
0318:  BRA    0320
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
031A:  MOVLW  7E
031C:  MOVWF  F95
....................                     kbd=~COL2&ALL_PINS; 
031E:  MOVWF  F83
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
0320:  BTFSS  0A.1
0322:  BRA    0336
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
0324:  MOVF   F83,W
0326:  ANDLW  1E
0328:  SUBLW  1E
032A:  BNZ   0334
....................            kbd_down=FALSE; 
032C:  BCF    0A.1
....................            kchar=last_key; 
032E:  MOVFF  0E,18
....................            last_key='\0'; 
0332:  CLRF   0E
....................          } 
....................        } else { 
0334:  BRA    039E
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
0336:  MOVF   F83,W
0338:  ANDLW  1E
033A:  SUBLW  1E
033C:  BZ    0394
....................              if((kbd & ROW0)==0) 
033E:  MOVF   F83,W
0340:  ANDLW  02
0342:  BNZ   0348
....................                row=0; 
0344:  CLRF   19
0346:  BRA    036A
....................              else if((kbd & ROW1)==0) 
0348:  MOVF   F83,W
034A:  ANDLW  04
034C:  BNZ   0354
....................                row=1; 
034E:  MOVLW  01
0350:  MOVWF  19
0352:  BRA    036A
....................              else if((kbd & ROW2)==0) 
0354:  MOVF   F83,W
0356:  ANDLW  08
0358:  BNZ   0360
....................                row=2; 
035A:  MOVLW  02
035C:  MOVWF  19
035E:  BRA    036A
....................              else if((kbd & ROW3)==0) 
0360:  MOVF   F83,W
0362:  ANDLW  10
0364:  BNZ   036A
....................                row=3; 
0366:  MOVLW  03
0368:  MOVWF  19
....................              last_key =KEYS[row][col]; 
036A:  MOVF   19,W
036C:  MULLW  03
036E:  MOVF   FF3,W
0370:  CLRF   1B
0372:  MOVWF  1A
0374:  CLRF   03
0376:  MOVF   0F,W
0378:  ADDWF  1A,W
037A:  MOVWF  01
037C:  MOVF   1B,W
037E:  ADDWFC 03,F
0380:  MOVF   01,W
0382:  MOVFF  FF2,1A
0386:  BCF    FF2.7
0388:  RCALL  0004
038A:  BTFSC  1A.7
038C:  BSF    FF2.7
038E:  MOVWF  0E
....................              kbd_down = TRUE; 
0390:  BSF    0A.1
....................           } else { 
0392:  BRA    039E
....................              ++col; 
0394:  INCF   0F,F
....................              if(col==3) 
0396:  MOVF   0F,W
0398:  SUBLW  03
039A:  BNZ   039E
....................                col=0; 
039C:  CLRF   0F
....................           } 
....................        } 
....................       kbd_call_count=0; 
039E:  CLRF   0D
....................    } 
....................   set_tris_kbd(ALL_PINS); 
03A0:  MOVLW  FE
03A2:  MOVWF  F95
....................   return(kchar); 
03A4:  MOVFF  18,01
03A8:  GOTO   08F2 (RETURN)
.................... } 
....................  
.................... //Função para iniciar o display 
.................... void Start(){    
....................    //LCD_Goto(coluna, linha);         
....................    LCD_Goto(3, 2);                          
*
0270:  MOVLW  03
0272:  MOVWF  18
0274:  MOVLW  02
0276:  MOVWF  19
0278:  RCALL  01E8
....................    LCD_Out("Carregando ."); 
027A:  MOVLW  20
027C:  MOVWF  FF6
027E:  MOVLW  00
0280:  MOVWF  FF7
0282:  RCALL  0250
....................    delay_ms(100); 
0284:  MOVLW  64
0286:  MOVWF  1B
0288:  RCALL  00FA
....................    LCD_Goto(14, 2); 
028A:  MOVLW  0E
028C:  MOVWF  18
028E:  MOVLW  02
0290:  MOVWF  19
0292:  RCALL  01E8
....................    LCD_Out(".");    
0294:  MOVLW  2E
0296:  MOVWF  FF6
0298:  MOVLW  00
029A:  MOVWF  FF7
029C:  RCALL  0250
....................    delay_ms(100); 
029E:  MOVLW  64
02A0:  MOVWF  1B
02A2:  RCALL  00FA
....................    LCD_Goto(15, 2); 
02A4:  MOVLW  0F
02A6:  MOVWF  18
02A8:  MOVLW  02
02AA:  MOVWF  19
02AC:  RCALL  01E8
....................    LCD_Out("."); 
02AE:  MOVLW  30
02B0:  MOVWF  FF6
02B2:  MOVLW  00
02B4:  MOVWF  FF7
02B6:  RCALL  0250
....................    delay_ms(100); 
02B8:  MOVLW  64
02BA:  MOVWF  1B
02BC:  RCALL  00FA
....................    LCD_Goto(16, 2); 
02BE:  MOVLW  10
02C0:  MOVWF  18
02C2:  MOVLW  02
02C4:  MOVWF  19
02C6:  RCALL  01E8
....................    LCD_Out("."); 
02C8:  MOVLW  32
02CA:  MOVWF  FF6
02CC:  MOVLW  00
02CE:  MOVWF  FF7
02D0:  RCALL  0250
....................    delay_ms(100); 
02D2:  MOVLW  64
02D4:  MOVWF  1B
02D6:  RCALL  00FA
....................    LCD_Goto(1, 2);    
02D8:  MOVLW  01
02DA:  MOVWF  18
02DC:  MOVLW  02
02DE:  MOVWF  19
02E0:  RCALL  01E8
....................    LCD_Cmd(LCD_CLEAR);                             //Limpara o display    
02E2:  MOVLW  01
02E4:  MOVWF  1B
02E6:  RCALL  0152
....................    delay_ms(100);    
02E8:  MOVLW  64
02EA:  MOVWF  1B
02EC:  RCALL  00FA
02EE:  GOTO   08D0 (RETURN)
.................... } 
....................  
....................  
.................... //Função feedback para fechar a porta 
.................... void CloseDoor(){ 
....................    LCD_Cmd(LCD_CLEAR);                             //Limpara o display   
*
0844:  MOVLW  01
0846:  MOVWF  1B
0848:  RCALL  0152
....................    delay_ms(100); 
084A:  MOVLW  64
084C:  MOVWF  1B
084E:  RCALL  00FA
....................    LCD_Goto(4,2); 
0850:  MOVLW  04
0852:  MOVWF  18
0854:  MOVLW  02
0856:  MOVWF  19
0858:  RCALL  01E8
....................    LCD_Out("Fecha Porta !!"); 
085A:  MOVLW  34
085C:  MOVWF  FF6
085E:  MOVLW  00
0860:  MOVWF  FF7
0862:  RCALL  0250
0864:  GOTO   09C0 (RETURN)
.................... } 
....................  
.................... // Função de constrole do andar das lâmpadas ========================================== 
.................... void Lamps(){                                       
*
0668:  MOVLW  D0
066A:  MOVWF  18
....................    unsigned int8 speed_ = 2000;                    //Velocidade dos motores    
....................    for(;;){                                        //Função para mover as lampadas 
....................       if(input(pin_B7)){                           //Teste para saber se está no final. Se não estiver ela irá para o ponto inicial          
066C:  BTFSS  F81.7
066E:  BRA    06F0
....................          for(int i=0; i<3; i++){                   //irá para o meio da pagina para começar a esterilização                          
0670:  CLRF   19
0672:  MOVF   19,W
0674:  SUBLW  02
0676:  BNC   06A4
....................             output_f(0b00000101); 
0678:  MOVLW  05
067A:  MOVWF  F8E
....................             delay_ms(speed_); 
067C:  MOVFF  18,1B
0680:  RCALL  00FA
....................             output_f(0b00000110); 
0682:  MOVLW  06
0684:  MOVWF  F8E
....................             delay_ms(speed_); 
0686:  MOVFF  18,1B
068A:  RCALL  00FA
....................             output_f(0b00001010); 
068C:  MOVLW  0A
068E:  MOVWF  F8E
....................             delay_ms(speed_); 
0690:  MOVFF  18,1B
0694:  RCALL  00FA
....................             output_f(0b00001001); 
0696:  MOVLW  09
0698:  MOVWF  F8E
....................             delay_ms(speed_);         
069A:  MOVFF  18,1B
069E:  RCALL  00FA
06A0:  INCF   19,F
06A2:  BRA    0672
....................          } 
....................          delay_ms(2000);                         //Tempo de espera de 40 segundos para esterelização   
06A4:  MOVLW  08
06A6:  MOVWF  1A
06A8:  MOVLW  FA
06AA:  MOVWF  1B
06AC:  RCALL  00FA
06AE:  DECFSZ 1A,F
06B0:  BRA    06A8
....................          for(;;){                                //Função que retornará as lampadas para o estágio inicial              
....................             output_f(0b00000110); 
06B2:  MOVLW  06
06B4:  MOVWF  F8E
....................             delay_ms(speed_); 
06B6:  MOVFF  18,1B
06BA:  RCALL  00FA
....................             if(input(pin_B7)) break; 
06BC:  BTFSC  F81.7
06BE:  BRA    06EC
....................             output_f(0b00000101); 
06C0:  MOVLW  05
06C2:  MOVWF  F8E
....................             delay_ms(speed_); 
06C4:  MOVFF  18,1B
06C8:  RCALL  00FA
....................             if(input(pin_B7)) break; 
06CA:  BTFSC  F81.7
06CC:  BRA    06EC
....................             output_f(0b00001001); 
06CE:  MOVLW  09
06D0:  MOVWF  F8E
....................             delay_ms(speed_); 
06D2:  MOVFF  18,1B
06D6:  RCALL  00FA
....................             if(input(pin_B7)) break; 
06D8:  BTFSC  F81.7
06DA:  BRA    06EC
....................             output_f(0b0001010); 
06DC:  MOVLW  0A
06DE:  MOVWF  F8E
....................             delay_ms(speed_); 
06E0:  MOVFF  18,1B
06E4:  RCALL  00FA
....................             if(input(pin_B7)) break; 
06E6:  BTFSC  F81.7
06E8:  BRA    06EC
06EA:  BRA    06B2
....................          }    
....................          break; 
06EC:  BRA    072C
....................       }else{                                    //Caso não esteja na posição inicial essa função irá levar até la                
06EE:  BRA    072A
....................          for(;;){                   
....................             output_f(0b00000110); 
06F0:  MOVLW  06
06F2:  MOVWF  F8E
....................             delay_ms(speed_); 
06F4:  MOVFF  18,1B
06F8:  RCALL  00FA
....................             if(input(pin_B7)) break;            //Teste se chegou na posição inicial 
06FA:  BTFSC  F81.7
06FC:  BRA    072A
....................             output_f(0b00000101); 
06FE:  MOVLW  05
0700:  MOVWF  F8E
....................             delay_ms(speed_); 
0702:  MOVFF  18,1B
0706:  RCALL  00FA
....................             if(input(pin_B7)) break; 
0708:  BTFSC  F81.7
070A:  BRA    072A
....................             output_f(0b00001001); 
070C:  MOVLW  09
070E:  MOVWF  F8E
....................             delay_ms(speed_); 
0710:  MOVFF  18,1B
0714:  RCALL  00FA
....................             if(input(pin_B7)) break; 
0716:  BTFSC  F81.7
0718:  BRA    072A
....................             output_f(0b00001010); 
071A:  MOVLW  0A
071C:  MOVWF  F8E
....................             delay_ms(speed_); 
071E:  MOVFF  18,1B
0722:  RCALL  00FA
....................             if(input(pin_B7)) break; 
0724:  BTFSC  F81.7
0726:  BRA    072A
0728:  BRA    06F0
....................          } 
....................       } 
072A:  BRA    066C
....................    }    
....................    delay_ms(2000);                              //Tempo de aguardo até passar as páginas 
072C:  MOVLW  08
072E:  MOVWF  1A
0730:  MOVLW  FA
0732:  MOVWF  1B
0734:  RCALL  00FA
0736:  DECFSZ 1A,F
0738:  BRA    0730
073A:  GOTO   09B6 (RETURN)
.................... } 
....................  
.................... //Função que irá passar as páginas =============================================================== 
.................... void PassadorPag(){    
073E:  MOVLW  E8
0740:  MOVWF  18
....................    unsigned int8 speed_ = 1000;           //Velocidade dos motores 
....................       for(;;){                               //Haste principal irá para a frente até encostar no livro 
....................       output_a(0b00000110); 
0742:  MOVLW  06
0744:  MOVWF  F89
....................       delay_ms(speed_); 
0746:  MOVFF  18,1B
074A:  RCALL  00FA
....................       if(input(pin_B3)) break;            //Teste se encostou no livro 
074C:  BTFSC  F81.3
074E:  BRA    077C
....................       output_a(0b00000101); 
0750:  MOVLW  05
0752:  MOVWF  F89
....................       delay_ms(speed_); 
0754:  MOVFF  18,1B
0758:  RCALL  00FA
....................       if(input(pin_B3)) break; 
075A:  BTFSC  F81.3
075C:  BRA    077C
....................       output_a(0b00001001); 
075E:  MOVLW  09
0760:  MOVWF  F89
....................       delay_ms(speed_); 
0762:  MOVFF  18,1B
0766:  RCALL  00FA
....................       if(input(pin_B3)) break; 
0768:  BTFSC  F81.3
076A:  BRA    077C
....................       output_a(0b00001010); 
076C:  MOVLW  0A
076E:  MOVWF  F89
....................       delay_ms(speed_); 
0770:  MOVFF  18,1B
0774:  RCALL  00FA
....................       if(input(pin_B3)) break; 
0776:  BTFSC  F81.3
0778:  BRA    077C
077A:  BRA    0742
....................    } 
....................    delay_ms(500); 
077C:  MOVLW  02
077E:  MOVWF  19
0780:  MOVLW  FA
0782:  MOVWF  1B
0784:  RCALL  00FA
0786:  DECFSZ 19,F
0788:  BRA    0780
....................    output_high(pin_B2);                    //Liga o FAN para segurar a página 
078A:  BSF    F8A.2
....................    delay_ms(1000);                        //Depois que tiver encostador irá parar e esperar até sugar a página 
078C:  MOVLW  04
078E:  MOVWF  19
0790:  MOVLW  FA
0792:  MOVWF  1B
0794:  RCALL  00FA
0796:  DECFSZ 19,F
0798:  BRA    0790
....................    for(;;){                               //Irá passar a pagina até encostar do outro lado 
....................       output_a(0b00000101); 
079A:  MOVLW  05
079C:  MOVWF  F89
....................       delay_ms(speed_); 
079E:  MOVFF  18,1B
07A2:  RCALL  00FA
....................       if(input(pin_B4)) break;            //Teste se chegou do outro lado 
07A4:  BTFSC  F81.4
07A6:  BRA    07D4
....................       output_a(0b00000110); 
07A8:  MOVLW  06
07AA:  MOVWF  F89
....................       delay_ms(speed_); 
07AC:  MOVFF  18,1B
07B0:  RCALL  00FA
....................       if(input(pin_B4)) break; 
07B2:  BTFSC  F81.4
07B4:  BRA    07D4
....................       output_a(0b00001010); 
07B6:  MOVLW  0A
07B8:  MOVWF  F89
....................       delay_ms(speed_); 
07BA:  MOVFF  18,1B
07BE:  RCALL  00FA
....................       if(input(pin_B4)) break; 
07C0:  BTFSC  F81.4
07C2:  BRA    07D4
....................       output_a(0b00001001); 
07C4:  MOVLW  09
07C6:  MOVWF  F89
....................       delay_ms(speed_);        
07C8:  MOVFF  18,1B
07CC:  RCALL  00FA
....................       if(input(pin_B4)) break; 
07CE:  BTFSC  F81.4
07D0:  BRA    07D4
07D2:  BRA    079A
....................    } 
....................    delay_ms(1000);                         
07D4:  MOVLW  04
07D6:  MOVWF  19
07D8:  MOVLW  FA
07DA:  MOVWF  1B
07DC:  RCALL  00FA
07DE:  DECFSZ 19,F
07E0:  BRA    07D8
....................    output_low(pin_B2);                    //Desliga a FAN do Passador 
07E2:  BCF    F8A.2
....................    delay_ms(1000);   
07E4:  MOVLW  04
07E6:  MOVWF  19
07E8:  MOVLW  FA
07EA:  MOVWF  1B
07EC:  RCALL  00FA
07EE:  DECFSZ 19,F
07F0:  BRA    07E8
....................                                  //Faz a haste secundária sair da pagina 
....................    output_f(0b00010000); 
07F2:  MOVLW  10
07F4:  MOVWF  F8E
....................    delay_ms(speed_); 
07F6:  MOVFF  18,1B
07FA:  RCALL  00FA
....................    output_f(0b00110000); 
07FC:  MOVLW  30
07FE:  MOVWF  F8E
....................    delay_ms(speed_); 
0800:  MOVFF  18,1B
0804:  RCALL  00FA
....................    output_f(0b00100000); 
0806:  MOVLW  20
0808:  MOVWF  F8E
....................    delay_ms(2000);   
080A:  MOVLW  08
080C:  MOVWF  19
080E:  MOVLW  FA
0810:  MOVWF  1B
0812:  RCALL  00FA
0814:  DECFSZ 19,F
0816:  BRA    080E
....................    //Faz a Haste primaria ficar na vertical 
....................    output_a(0b00000110); 
0818:  MOVLW  06
081A:  MOVWF  F89
....................    delay_ms(speed_);    
081C:  MOVFF  18,1B
0820:  RCALL  00FA
....................    output_a(0b00000101); 
0822:  MOVLW  05
0824:  MOVWF  F89
....................    delay_ms(speed_); 
0826:  MOVFF  18,1B
082A:  RCALL  00FA
....................    //Faz a haste secudária voltar para a posição original 
....................    output_f(0b00110000);       
082C:  MOVLW  30
082E:  MOVWF  F8E
....................    delay_ms(speed_); 
0830:  MOVFF  18,1B
0834:  RCALL  00FA
....................    output_f(0b00010000); 
0836:  MOVLW  10
0838:  MOVWF  F8E
....................    delay_ms(speed_);               
083A:  MOVFF  18,1B
083E:  RCALL  00FA
0840:  GOTO   09B8 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... //Variaveis para guardar valores do teclados 
.................... char k = 0; 
.................... char valuePagesChar[4]; 
.................... int cont=0; 
.................... int valuePages = 0; //Quantidade de paginas que tem o livro 
.................... //=========================================== 
....................  
.................... void main() 
*
0868:  CLRF   FF8
086A:  BCF    FD0.7
086C:  MOVLW  70
086E:  MOVWF  FD3
0870:  MOVF   FD3,W
0872:  BCF    F7E.3
0874:  MOVLW  0C
0876:  MOVWF  FAF
0878:  MOVLW  A2
087A:  MOVWF  FAC
087C:  MOVLW  90
087E:  MOVWF  FAB
0880:  MOVLW  08
0882:  MOVWF  0C
0884:  CLRF   10
0886:  CLRF   15
0888:  CLRF   16
088A:  MOVLB  F
088C:  CLRF   x59
088E:  CLRF   x58
0890:  CLRF   x5A
0892:  CLRF   x5B
0894:  CLRF   x5C
0896:  CLRF   x5D
0898:  CLRF   x5E
089A:  CLRF   x5F
089C:  MOVF   FC1,W
089E:  ANDLW  C0
08A0:  IORLW  0F
08A2:  MOVWF  FC1
08A4:  MOVLW  07
08A6:  MOVWF  FB4
08A8:  BCF    0A.1
08AA:  CLRF   04
08AC:  CLRF   05
08AE:  CLRF   0D
08B0:  BCF    0A.1
08B2:  CLRF   0E
08B4:  CLRF   0F
.................... { 
....................    output_b(0);     
08B6:  CLRF   F8A
....................    output_d(0);  
08B8:  CLRF   F8C
....................    output_c(0);  
08BA:  CLRF   F8B
....................    //set_tris_b(0b1111000); //setando as portas como 1=input || 0=output 
....................    set_tris_a(0b11000000); 
08BC:  MOVLW  C0
08BE:  MOVWF  F92
....................    set_tris_f(0b00000000); 
08C0:  MOVLW  00
08C2:  MOVWF  F97
....................    LCD_Begin(0x4E); 
08C4:  MOVLW  4E
08C6:  MOVWF  18
08C8:  MOVLB  0
08CA:  BRA    0172
....................    kbd_init(); 
08CC:  BRA    01E4
....................    Start();         
08CE:  BRA    0270
....................    LCD_Goto(2,2); 
08D0:  MOVLW  02
08D2:  MOVWF  18
08D4:  MOVWF  19
08D6:  RCALL  01E8
....................    LCD_Out("Qts paginas:"); 
08D8:  MOVLW  44
08DA:  MOVWF  FF6
08DC:  MOVLW  00
08DE:  MOVWF  FF7
08E0:  RCALL  0250
....................    LCD_Goto(14,2); 
08E2:  MOVLW  0E
08E4:  MOVWF  18
08E6:  MOVLW  02
08E8:  MOVWF  19
08EA:  RCALL  01E8
....................    while(TRUE){   
....................       while(valuePages == 0){                                     //Loop para pegar valor do teclado          
08EC:  MOVF   16,F
08EE:  BNZ   0958
....................          k = kbd_getc();                                          // read keypad input (if exists)  
08F0:  BRA    02F2
08F2:  MOVFF  01,10
....................          if(k!=0 && k!='*' && k !="#" && cont<4){                 // se a tecla for captaurada e não for "*" ou "#" ou for menor que 4 digitos       
08F6:  MOVF   10,F
08F8:  BZ    0938
08FA:  MOVF   10,W
08FC:  SUBLW  2A
08FE:  BZ    0938
0900:  MOVLW  00
0902:  MOVWF  03
0904:  MOVLW  52
0906:  SUBWF  10,W
0908:  BNZ   090E
090A:  MOVF   03,F
090C:  BZ    0938
090E:  MOVF   15,W
0910:  SUBLW  03
0912:  BNC   0938
....................             LCD_Out(k);                                           // print captured key to lcd 
0914:  MOVFF  10,1F
0918:  RCALL  0230
....................             valuePagesChar[cont] = k; 
091A:  CLRF   03
091C:  MOVF   15,W
091E:  ADDLW  11
0920:  MOVWF  FE9
0922:  MOVLW  00
0924:  ADDWFC 03,W
0926:  MOVWF  FEA
0928:  MOVFF  10,FEF
....................             k=0;                                                  // reset k for another loop round 
092C:  CLRF   10
....................             cont++; 
092E:  INCF   15,F
....................             delay_ms(250);                                        // delay between key presses 
0930:  MOVLW  FA
0932:  MOVWF  1B
0934:  CALL   00FA
....................          }  
....................          delay_ms(1); 
0938:  MOVLW  01
093A:  MOVWF  1B
093C:  CALL   00FA
....................          if(input(pin_B5)){ 
0940:  BTFSS  F81.5
0942:  BRA    0956
....................             valuePages= atoi(valuePagesChar);  
0944:  CLRF   19
0946:  MOVLW  11
0948:  MOVWF  18
094A:  BRA    03F8
094C:  MOVFF  01,16
....................             if(valuePages != 0){ 
0950:  MOVF   16,F
0952:  BZ    0956
....................                break; 
0954:  BRA    0958
....................             } 
....................          }     
0956:  BRA    08EC
....................       }       
....................       if(input(pin_B6)){                   //Teste para ver se as portas estão fechadas 
0958:  BTFSS  F81.6
095A:  BRA    09BE
....................          LCD_Cmd(LCD_CLEAR);                             //Limpara o display 
095C:  MOVLW  01
095E:  MOVWF  1B
0960:  CALL   0152
....................          delay_ms(100); 
0964:  MOVLW  64
0966:  MOVWF  1B
0968:  CALL   00FA
....................          LCD_Goto(7,2); 
096C:  MOVLW  07
096E:  MOVWF  18
0970:  MOVLW  02
0972:  MOVWF  19
0974:  RCALL  01E8
....................          LCD_Out("Iniciado!!"); 
0976:  MOVLW  54
0978:  MOVWF  FF6
097A:  MOVLW  00
097C:  MOVWF  FF7
097E:  RCALL  0250
....................          LCD_Goto(1,3); 
0980:  MOVLW  01
0982:  MOVWF  18
0984:  MOVLW  03
0986:  MOVWF  19
0988:  RCALL  01E8
....................          LCD_Out("Pag. restantes:"); 
098A:  MOVLW  60
098C:  MOVWF  FF6
098E:  MOVLW  00
0990:  MOVWF  FF7
0992:  RCALL  0250
....................          for(int i=0; i<valuePages;i++){   
0994:  CLRF   17
0996:  MOVF   16,W
0998:  SUBWF  17,W
099A:  BC    09BC
....................             LCD_Goto(17,3);                
099C:  MOVLW  11
099E:  MOVWF  18
09A0:  MOVLW  03
09A2:  MOVWF  19
09A4:  RCALL  01E8
....................             printf(lcd_out, "%d", valuePages-i);    
09A6:  MOVF   17,W
09A8:  SUBWF  16,W
09AA:  MOVWF  18
09AC:  MOVWF  19
09AE:  MOVLW  18
09B0:  MOVWF  1A
09B2:  BRA    05BC
....................             Lamps(); 
09B4:  BRA    0668
....................             PassadorPag(); 
09B6:  BRA    073E
09B8:  INCF   17,F
09BA:  BRA    0996
....................          } 
....................       }else{                                               //Teste para as portas fechadas  
09BC:  BRA    09C0
....................             CloseDoor();                                 
09BE:  BRA    0844
....................       }       
09C0:  BRA    08EC
....................    }    
.................... } 
....................  
09C2:  SLEEP 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 05C3   CCP2C1 LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOXINST NODEBUG
   Word  5: 0001   NOPROTECT
   Word  6: 0000  
   Word  7: 0001  
