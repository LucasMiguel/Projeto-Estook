CCS PCH C Compiler, Version 5.015, 5967               22-nov-20 17:07

               Filename:   C:\Users\lucas\Documents\Faculdade\2-2020\Projeto interdiciplinar\Programação\Projeto\code\main.lst

               ROM used:   1044 bytes (3%)
                           Largest free fragment is 31724
               RAM used:   6 (0%) at main() level
                           20 (1%) worst case
               Stack used: 7 locations
               Stack size: 31

*
0000:  GOTO   03B0
.................... //LCD module connections 
.................... #define LCD_RS_PIN PIN_D0 
.................... #define LCD_RW_PIN PIN_D1 
.................... #define LCD_ENABLE_PIN PIN_D2 
.................... #define LCD_DATA4 PIN_D3 
.................... #define LCD_DATA5 PIN_D4 
.................... #define LCD_DATA6 PIN_D5 
.................... #define LCD_DATA7 PIN_D6 
.................... //End LCD module connections 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  DATA 43,61
0006:  DATA 72,72
0008:  DATA 65,67
000A:  DATA 61,6E
000C:  DATA 64,6F
000E:  DATA 20,2E
0010:  DATA 00,00
0012:  DATA 2E,00
0014:  DATA 2E,00
0016:  DATA 2E,00
0018:  DATA 43,6C
001A:  DATA 69,71
001C:  DATA 75,65
001E:  DATA 20,65
0020:  DATA 6D,20
0022:  DATA 69,6E
0024:  DATA 69,63
0026:  DATA 69,61
0028:  DATA 72,00
002A:  DATA 50,61
002C:  DATA 72,61
002E:  DATA 20,46
0030:  DATA 72,65
0032:  DATA 6E,74
0034:  DATA 65,00
0036:  DATA 50,61
0038:  DATA 72,61
003A:  DATA 20,54
003C:  DATA 72,61
003E:  DATA 73,00
0040:  DATA 50,61
0042:  DATA 73,73
0044:  DATA 61,6E
0046:  DATA 64,6F
0048:  DATA 20,70
004A:  DATA 61,67
004C:  DATA 69,6E
004E:  DATA 61,00
0050:  DATA 49,6E
0052:  DATA 69,63
0054:  DATA 69,61
0056:  DATA 64,6F
0058:  DATA 00,00
005A:  DATA 46,65
005C:  DATA 63,68
005E:  DATA 61,20
0060:  DATA 50,6F
0062:  DATA 72,74
0064:  DATA 61,00
*
0274:  TBLRD*+
0276:  MOVF   FF5,F
0278:  BZ    0292
027A:  MOVFF  FF6,07
027E:  MOVFF  FF7,08
0282:  MOVFF  FF5,09
0286:  RCALL  0224
0288:  MOVFF  07,FF6
028C:  MOVFF  08,FF7
0290:  BRA    0274
0292:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOMCLR NOBROWNOUT NOLVP INTRC_IO 
.................... #device ADC = 10 
.................... #use delay(clock = 8000000) 
*
0066:  CLRF   FEA
0068:  MOVLW  0B
006A:  MOVWF  FE9
006C:  MOVF   FEF,W
006E:  BZ    008A
0070:  MOVLW  02
0072:  MOVWF  01
0074:  CLRF   00
0076:  DECFSZ 00,F
0078:  BRA    0076
007A:  DECFSZ 01,F
007C:  BRA    0074
007E:  MOVLW  97
0080:  MOVWF  00
0082:  DECFSZ 00,F
0084:  BRA    0082
0086:  DECFSZ FEF,F
0088:  BRA    0070
008A:  RETURN 0
.................... #use fast_io(B) 
.................... #use fast_io(D) 
.................... #use fast_io(C) 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
010A:  BSF    F95.3
....................    output_float(LCD_DATA5); 
010C:  BSF    F95.4
....................    output_float(LCD_DATA6); 
010E:  BSF    F95.5
....................    output_float(LCD_DATA7); 
0110:  BSF    F95.6
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0112:  BSF    F8C.1
....................    delay_cycles(1); 
0114:  NOP   
....................    lcd_output_enable(1); 
0116:  BSF    F8C.2
....................    delay_cycles(1); 
0118:  NOP   
....................    high = lcd_read_nibble(); 
011A:  RCALL  00C0
011C:  MOVFF  01,11
....................        
....................    lcd_output_enable(0); 
0120:  BCF    F8C.2
....................    delay_cycles(1); 
0122:  NOP   
....................    lcd_output_enable(1); 
0124:  BSF    F8C.2
....................    delay_us(1); 
0126:  BRA    0128
....................    low = lcd_read_nibble(); 
0128:  RCALL  00C0
012A:  MOVFF  01,10
....................        
....................    lcd_output_enable(0); 
012E:  BCF    F8C.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0130:  BCF    F95.3
....................    output_drive(LCD_DATA5); 
0132:  BCF    F95.4
....................    output_drive(LCD_DATA6); 
0134:  BCF    F95.5
....................    output_drive(LCD_DATA7); 
0136:  BCF    F95.6
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0138:  SWAPF  11,W
013A:  MOVWF  00
013C:  MOVLW  F0
013E:  ANDWF  00,F
0140:  MOVF   00,W
0142:  IORWF  10,W
0144:  MOVWF  01
0146:  GOTO   0154 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00C0:  CLRF   12
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00C2:  MOVLW  00
00C4:  BTFSC  F83.3
00C6:  MOVLW  01
00C8:  IORWF  12,F
....................    n |= input(LCD_DATA5) << 1; 
00CA:  MOVLW  00
00CC:  BTFSC  F83.4
00CE:  MOVLW  01
00D0:  MOVWF  00
00D2:  BCF    FD8.0
00D4:  RLCF   00,F
00D6:  MOVF   00,W
00D8:  IORWF  12,F
....................    n |= input(LCD_DATA6) << 2; 
00DA:  MOVLW  00
00DC:  BTFSC  F83.5
00DE:  MOVLW  01
00E0:  MOVWF  00
00E2:  RLCF   00,F
00E4:  RLCF   00,F
00E6:  MOVLW  FC
00E8:  ANDWF  00,F
00EA:  MOVF   00,W
00EC:  IORWF  12,F
....................    n |= input(LCD_DATA7) << 3; 
00EE:  MOVLW  00
00F0:  BTFSC  F83.6
00F2:  MOVLW  01
00F4:  MOVWF  00
00F6:  RLCF   00,F
00F8:  RLCF   00,F
00FA:  RLCF   00,F
00FC:  MOVLW  F8
00FE:  ANDWF  00,F
0100:  MOVF   00,W
0102:  IORWF  12,F
....................     
....................    return(n); 
0104:  MOVFF  12,01
....................   #else 
0108:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
008C:  BTFSC  11.0
008E:  BRA    0094
0090:  BCF    F8C.3
0092:  BRA    0096
0094:  BSF    F8C.3
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0096:  BTFSC  11.1
0098:  BRA    009E
009A:  BCF    F8C.4
009C:  BRA    00A0
009E:  BSF    F8C.4
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00A0:  BTFSC  11.2
00A2:  BRA    00A8
00A4:  BCF    F8C.5
00A6:  BRA    00AA
00A8:  BSF    F8C.5
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00AA:  BTFSC  11.3
00AC:  BRA    00B2
00AE:  BCF    F8C.6
00B0:  BRA    00B4
00B2:  BSF    F8C.6
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00B4:  NOP   
....................    lcd_output_enable(1); 
00B6:  BSF    F8C.2
....................    delay_us(2); 
00B8:  BRA    00BA
00BA:  BRA    00BC
....................    lcd_output_enable(0); 
00BC:  BCF    F8C.2
00BE:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
014A:  BCF    F95.2
....................    lcd_rs_tris(); 
014C:  BCF    F95.0
....................    lcd_rw_tris(); 
014E:  BCF    F95.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0150:  BCF    F8C.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
0152:  BRA    010A
0154:  MOVFF  01,10
0158:  BTFSC  01.7
015A:  BRA    0152
....................    lcd_output_rs(address); 
015C:  MOVF   0E,F
015E:  BNZ   0164
0160:  BCF    F8C.0
0162:  BRA    0166
0164:  BSF    F8C.0
....................    delay_cycles(1); 
0166:  NOP   
....................    lcd_output_rw(0); 
0168:  BCF    F8C.1
....................    delay_cycles(1); 
016A:  NOP   
....................    lcd_output_enable(0); 
016C:  BCF    F8C.2
....................    lcd_send_nibble(n >> 4); 
016E:  SWAPF  0F,W
0170:  MOVWF  10
0172:  MOVLW  0F
0174:  ANDWF  10,F
0176:  MOVFF  10,11
017A:  RCALL  008C
....................    lcd_send_nibble(n & 0xf); 
017C:  MOVF   0F,W
017E:  ANDLW  0F
0180:  MOVWF  10
0182:  MOVWF  11
0184:  RCALL  008C
0186:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0188:  MOVLW  28
018A:  MOVWF  07
018C:  MOVLW  0C
018E:  MOVWF  08
0190:  MOVLW  01
0192:  MOVWF  09
0194:  MOVLW  06
0196:  MOVWF  0A
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0198:  BCF    F8C.2
....................    lcd_output_rs(0); 
019A:  BCF    F8C.0
....................    lcd_output_rw(0); 
019C:  BCF    F8C.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
019E:  BCF    F95.3
....................    output_drive(LCD_DATA5); 
01A0:  BCF    F95.4
....................    output_drive(LCD_DATA6); 
01A2:  BCF    F95.5
....................    output_drive(LCD_DATA7); 
01A4:  BCF    F95.6
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
01A6:  BCF    F95.2
....................    lcd_rs_tris(); 
01A8:  BCF    F95.0
....................    lcd_rw_tris(); 
01AA:  BCF    F95.1
....................  #endif 
....................      
....................    delay_ms(15); 
01AC:  MOVLW  0F
01AE:  MOVWF  0B
01B0:  RCALL  0066
....................    for(i=1;i<=3;++i) 
01B2:  MOVLW  01
01B4:  MOVWF  06
01B6:  MOVF   06,W
01B8:  SUBLW  03
01BA:  BNC   01CC
....................    { 
....................        lcd_send_nibble(3); 
01BC:  MOVLW  03
01BE:  MOVWF  11
01C0:  RCALL  008C
....................        delay_ms(5); 
01C2:  MOVLW  05
01C4:  MOVWF  0B
01C6:  RCALL  0066
01C8:  INCF   06,F
01CA:  BRA    01B6
....................    } 
....................     
....................    lcd_send_nibble(2); 
01CC:  MOVLW  02
01CE:  MOVWF  11
01D0:  RCALL  008C
....................    delay_ms(5); 
01D2:  MOVLW  05
01D4:  MOVWF  0B
01D6:  RCALL  0066
....................    for(i=0;i<=3;++i) 
01D8:  CLRF   06
01DA:  MOVF   06,W
01DC:  SUBLW  03
01DE:  BNC   01FE
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
01E0:  CLRF   03
01E2:  MOVF   06,W
01E4:  ADDLW  07
01E6:  MOVWF  FE9
01E8:  MOVLW  00
01EA:  ADDWFC 03,W
01EC:  MOVWF  FEA
01EE:  MOVFF  FEF,0B
01F2:  CLRF   0E
01F4:  MOVFF  0B,0F
01F8:  RCALL  014A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01FA:  INCF   06,F
01FC:  BRA    01DA
01FE:  GOTO   0296 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0202:  DECFSZ 0B,W
0204:  BRA    0208
0206:  BRA    020E
....................       address=LCD_LINE_TWO; 
0208:  MOVLW  40
020A:  MOVWF  0C
020C:  BRA    0210
....................    else 
....................       address=0; 
020E:  CLRF   0C
....................       
....................    address+=x-1; 
0210:  MOVLW  01
0212:  SUBWF  0A,W
0214:  ADDWF  0C,F
....................    lcd_send_byte(0,0x80|address); 
0216:  MOVF   0C,W
0218:  IORLW  80
021A:  MOVWF  0D
021C:  CLRF   0E
021E:  MOVWF  0F
0220:  RCALL  014A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0222:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0224:  MOVF   09,W
0226:  XORLW  07
0228:  BZ    0238
022A:  XORLW  0B
022C:  BZ    0242
022E:  XORLW  06
0230:  BZ    0252
0232:  XORLW  02
0234:  BZ    025E
0236:  BRA    0268
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0238:  MOVLW  01
023A:  MOVWF  0A
023C:  MOVWF  0B
023E:  RCALL  0202
0240:  BRA    0272
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0242:  CLRF   0E
0244:  MOVLW  01
0246:  MOVWF  0F
0248:  RCALL  014A
....................                      delay_ms(2); 
024A:  MOVLW  02
024C:  MOVWF  0B
024E:  RCALL  0066
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0250:  BRA    0272
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0252:  MOVLW  01
0254:  MOVWF  0A
0256:  MOVLW  02
0258:  MOVWF  0B
025A:  RCALL  0202
025C:  BRA    0272
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
025E:  CLRF   0E
0260:  MOVLW  10
0262:  MOVWF  0F
0264:  RCALL  014A
0266:  BRA    0272
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0268:  MOVLW  01
026A:  MOVWF  0E
026C:  MOVFF  09,0F
0270:  RCALL  014A
....................      #endif 
....................    } 
0272:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <functions.h> 
.................... //Função para iniciar o display 
.................... void Start(){ 
....................    lcd_init();  // Initialize LCD module 
*
0294:  BRA    0188
....................    lcd_putc('\f');                                // Clear LCD 
0296:  MOVLW  0C
0298:  MOVWF  09
029A:  RCALL  0224
....................    lcd_gotoxy(4, 2);                              // Go to column 2 row 1 
029C:  MOVLW  04
029E:  MOVWF  0A
02A0:  MOVLW  02
02A2:  MOVWF  0B
02A4:  RCALL  0202
....................    lcd_putc("Carregando ."); 
02A6:  MOVLW  04
02A8:  MOVWF  FF6
02AA:  MOVLW  00
02AC:  MOVWF  FF7
02AE:  RCALL  0274
....................    delay_ms(300); 
02B0:  MOVLW  02
02B2:  MOVWF  06
02B4:  MOVLW  96
02B6:  MOVWF  0B
02B8:  RCALL  0066
02BA:  DECFSZ 06,F
02BC:  BRA    02B4
....................    lcd_gotoxy(14, 2); 
02BE:  MOVLW  0E
02C0:  MOVWF  0A
02C2:  MOVLW  02
02C4:  MOVWF  0B
02C6:  RCALL  0202
....................    lcd_putc(".");    
02C8:  MOVLW  12
02CA:  MOVWF  FF6
02CC:  MOVLW  00
02CE:  MOVWF  FF7
02D0:  RCALL  0274
....................    delay_ms(300); 
02D2:  MOVLW  02
02D4:  MOVWF  06
02D6:  MOVLW  96
02D8:  MOVWF  0B
02DA:  RCALL  0066
02DC:  DECFSZ 06,F
02DE:  BRA    02D6
....................    lcd_gotoxy(15, 2); 
02E0:  MOVLW  0F
02E2:  MOVWF  0A
02E4:  MOVLW  02
02E6:  MOVWF  0B
02E8:  RCALL  0202
....................    lcd_putc("."); 
02EA:  MOVLW  14
02EC:  MOVWF  FF6
02EE:  MOVLW  00
02F0:  MOVWF  FF7
02F2:  RCALL  0274
....................    delay_ms(300); 
02F4:  MOVLW  02
02F6:  MOVWF  06
02F8:  MOVLW  96
02FA:  MOVWF  0B
02FC:  RCALL  0066
02FE:  DECFSZ 06,F
0300:  BRA    02F8
....................    lcd_gotoxy(16, 2); 
0302:  MOVLW  10
0304:  MOVWF  0A
0306:  MOVLW  02
0308:  MOVWF  0B
030A:  RCALL  0202
....................    lcd_putc("."); 
030C:  MOVLW  16
030E:  MOVWF  FF6
0310:  MOVLW  00
0312:  MOVWF  FF7
0314:  RCALL  0274
....................    delay_ms(300); 
0316:  MOVLW  02
0318:  MOVWF  06
031A:  MOVLW  96
031C:  MOVWF  0B
031E:  RCALL  0066
0320:  DECFSZ 06,F
0322:  BRA    031A
....................    lcd_putc('\f');    
0324:  MOVLW  0C
0326:  MOVWF  09
0328:  RCALL  0224
....................    lcd_gotoxy(2, 2);                              // Go to column 2 row 3 
032A:  MOVLW  02
032C:  MOVWF  0A
032E:  MOVWF  0B
0330:  RCALL  0202
....................    lcd_putc("Clique em iniciar");  
0332:  MOVLW  18
0334:  MOVWF  FF6
0336:  MOVLW  00
0338:  MOVWF  FF7
033A:  RCALL  0274
033C:  GOTO   03D4 (RETURN)
.................... } 
....................  
.................... void Lamps(){ 
....................    unsigned int8 speed_; 
....................    lcd_putc('\f');    
....................    lcd_gotoxy(2, 2);     
....................    for(;;){ 
....................       if(input(pin_B7)){ 
....................          lcd_putc("Para Frente"); 
....................          for(int i=0; i<3; i++){ 
....................             speed_ = 1000; 
....................             output_c(0b00000101); 
....................             delay_ms(speed_); 
....................             output_c(0b00000110); 
....................             delay_ms(speed_); 
....................             output_c(0b00010010); 
....................             delay_ms(speed_); 
....................             output_c(0b00010001); 
....................             delay_ms(speed_);         
....................          } 
....................          delay_ms(2000); 
....................          for(;;){       
....................             speed_ = 1000; 
....................             output_c(0b00000110); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00000101); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010001); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010010); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................          }    
....................          break; 
....................       }else{ 
....................          lcd_putc("Para Tras"); 
....................          for(;;){       
....................             speed_ = 1000; 
....................             output_c(0b00000110); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00000101); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010001); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010010); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................          } 
....................       } 
....................    }    
....................    delay_ms(2000); 
.................... } 
....................  
.................... void PassadorPag(){ 
....................    unsigned int8 speed_; 
....................    lcd_putc('\f');    
0340:  MOVLW  0C
0342:  MOVWF  09
0344:  RCALL  0224
....................    lcd_gotoxy(2, 2);   
0346:  MOVLW  02
0348:  MOVWF  0A
034A:  MOVWF  0B
034C:  RCALL  0202
....................    lcd_putc("Passando pagina");  
034E:  MOVLW  40
0350:  MOVWF  FF6
0352:  MOVLW  00
0354:  MOVWF  FF7
0356:  RCALL  0274
....................    for(;;){       
....................       speed_ = 1000; 
0358:  MOVLW  E8
035A:  MOVWF  06
....................       output_a(0b00000110); 
035C:  CLRF   F92
035E:  MOVLW  06
0360:  MOVWF  F89
....................       delay_ms(speed_); 
0362:  MOVFF  06,0B
0366:  RCALL  0066
....................       if(input(pin_B3)) break; 
0368:  BTFSC  F81.3
036A:  BRA    039E
....................       output_a(0b00000101); 
036C:  CLRF   F92
036E:  MOVLW  05
0370:  MOVWF  F89
....................       delay_ms(speed_); 
0372:  MOVFF  06,0B
0376:  RCALL  0066
....................       if(input(pin_B3)) break; 
0378:  BTFSC  F81.3
037A:  BRA    039E
....................       output_a(0b00001001); 
037C:  CLRF   F92
037E:  MOVLW  09
0380:  MOVWF  F89
....................       delay_ms(speed_); 
0382:  MOVFF  06,0B
0386:  RCALL  0066
....................       if(input(pin_B3)) break; 
0388:  BTFSC  F81.3
038A:  BRA    039E
....................       output_a(0b00001010); 
038C:  CLRF   F92
038E:  MOVLW  0A
0390:  MOVWF  F89
....................       delay_ms(speed_); 
0392:  MOVFF  06,0B
0396:  RCALL  0066
....................       if(input(pin_B3)) break; 
0398:  BTFSC  F81.3
039A:  BRA    039E
039C:  BRA    0358
....................    } 
....................    delay_ms(2000); 
039E:  MOVLW  08
03A0:  MOVWF  07
03A2:  MOVLW  FA
03A4:  MOVWF  0B
03A6:  RCALL  0066
03A8:  DECFSZ 07,F
03AA:  BRA    03A2
03AC:  GOTO   03F8 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void main() 
03B0:  CLRF   FF8
03B2:  BCF    FD0.7
03B4:  MOVLW  70
03B6:  MOVWF  FD3
03B8:  MOVF   FD3,W
03BA:  MOVF   FC1,W
03BC:  ANDLW  C0
03BE:  IORLW  0F
03C0:  MOVWF  FC1
03C2:  MOVLW  07
03C4:  MOVWF  FB4
03C6:  CLRF   04
03C8:  CLRF   05
.................... { 
....................    //output_b(0);     
....................    output_d(0);  
03CA:  CLRF   F8C
....................    output_c(0);     
03CC:  CLRF   F8B
....................    set_tris_c(0);     
03CE:  MOVLW  00
03D0:  MOVWF  F94
....................    Start(); 
03D2:  BRA    0294
....................    while(TRUE){ 
....................       if(input(pin_B5)){ 
03D4:  BTFSS  F81.5
03D6:  BRA    040A
....................          lcd_gotoxy(4, 2); 
03D8:  MOVLW  04
03DA:  MOVWF  0A
03DC:  MOVLW  02
03DE:  MOVWF  0B
03E0:  RCALL  0202
....................          if(input(pin_B6)){             
03E2:  BTFSS  F81.6
03E4:  BRA    03FA
....................                lcd_putc('\f');                                // Clear LCD 
03E6:  MOVLW  0C
03E8:  MOVWF  09
03EA:  RCALL  0224
....................                lcd_putc("Iniciado");                          // E já liga a lâmpada enquanto a porta está fechada    
03EC:  MOVLW  50
03EE:  MOVWF  FF6
03F0:  MOVLW  00
03F2:  MOVWF  FF7
03F4:  RCALL  0274
....................                //Lamps(); 
....................                PassadorPag(); 
03F6:  BRA    0340
....................          }else{                                               //Teste para as portas fechadas  
03F8:  BRA    040A
....................                lcd_putc('\f');                                 
03FA:  MOVLW  0C
03FC:  MOVWF  09
03FE:  RCALL  0224
....................                lcd_putc("Fecha Porta");                            
0400:  MOVLW  5A
0402:  MOVWF  FF6
0404:  MOVLW  00
0406:  MOVWF  FF7
0408:  RCALL  0274
....................          } 
....................       } 
....................       delay_ms(200); 
040A:  MOVLW  C8
040C:  MOVWF  0B
040E:  RCALL  0066
0410:  BRA    03D4
....................    } 
.................... } 
....................  
0412:  SLEEP 
....................  

Configuration Fuses:
   Word  1: C83F   PLL12 CPUDIV4 USBDIV INTRC_IO FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
