CCS PCH C Compiler, Version 5.015, 5967               23-nov-20 00:14

               Filename:   C:\Users\lucas\Documents\Faculdade\2-2020\Projeto interdiciplinar\Programação\Projeto\code\main.lst

               ROM used:   632 bytes (2%)
                           Largest free fragment is 32136
               RAM used:   9 (0%) at main() level
                           17 (1%) worst case
               Stack used: 5 locations
               Stack size: 31

*
0000:  GOTO   0230
.................... //LCD module connections 
.................... #define LCD_RS_PIN PIN_D0 
.................... #define LCD_RW_PIN PIN_D1 
.................... #define LCD_ENABLE_PIN PIN_D2 
.................... #define LCD_DATA4 PIN_D3 
.................... #define LCD_DATA5 PIN_D4 
.................... #define LCD_DATA6 PIN_D5 
.................... #define LCD_DATA7 PIN_D6 
.................... //End LCD module connections 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  DATA 43,61
0006:  DATA 72,72
0008:  DATA 65,67
000A:  DATA 61,6E
000C:  DATA 64,6F
000E:  DATA 20,2E
0010:  DATA 00,00
0012:  DATA 2E,00
0014:  DATA 2E,00
0016:  DATA 2E,00
0018:  DATA 20,20
001A:  DATA 20,20
001C:  DATA 20,20
001E:  DATA 20,20
0020:  DATA 20,20
0022:  DATA 20,20
0024:  DATA 20,20
0026:  DATA 20,20
0028:  DATA 20,20
002A:  DATA 20,20
002C:  DATA 00,00
002E:  DATA 43,6C
0030:  DATA 69,71
0032:  DATA 75,65
0034:  DATA 20,65
0036:  DATA 6D,20
0038:  DATA 69,6E
003A:  DATA 69,63
003C:  DATA 69,61
003E:  DATA 72,00
0040:  DATA 20,20
0042:  DATA 20,20
0044:  DATA 20,20
0046:  DATA 20,20
0048:  DATA 20,20
004A:  DATA 20,20
004C:  DATA 20,20
004E:  DATA 20,20
0050:  DATA 20,20
0052:  DATA 20,20
0054:  DATA 00,00
0056:  DATA 46,65
0058:  DATA 63,68
005A:  DATA 61,20
005C:  DATA 50,6F
005E:  DATA 72,74
0060:  DATA 61,00
....................  
.................... #list 
....................  
.................... #fuses NOMCLR NOBROWNOUT NOLVP INTRC_IO  
.................... #device ADC = 10 
.................... #use delay(clock = 8000000) 
*
00EC:  CLRF   FEA
00EE:  MOVLW  0B
00F0:  MOVWF  FE9
00F2:  MOVF   FEF,W
00F4:  BZ    0110
00F6:  MOVLW  02
00F8:  MOVWF  01
00FA:  CLRF   00
00FC:  DECFSZ 00,F
00FE:  BRA    00FC
0100:  DECFSZ 01,F
0102:  BRA    00FA
0104:  MOVLW  97
0106:  MOVWF  00
0108:  DECFSZ 00,F
010A:  BRA    0108
010C:  DECFSZ FEF,F
010E:  BRA    00F6
0110:  RETURN 0
.................... #use fast_io(B) 
.................... #use fast_io(D) 
.................... #use fast_io(C) 
.................... #use I2C(master, sda=PIN_b0, scl=PIN_b1, ADDRESS = 0X01, FAST =100000, STREAM = I2C_LCD) 
*
0062:  MOVLW  08
0064:  MOVWF  01
0066:  BRA    0068
0068:  BCF    F8A.1
006A:  BCF    F93.1
006C:  BRA    006E
006E:  NOP   
0070:  RLCF   10,F
0072:  BCF    F8A.0
0074:  BTFSC  FD8.0
0076:  BSF    F93.0
0078:  BTFSS  FD8.0
007A:  BCF    F93.0
007C:  BSF    F93.1
007E:  BTFSS  F81.1
0080:  BRA    007E
0082:  DECFSZ 01,F
0084:  BRA    0066
0086:  BRA    0088
0088:  BCF    F8A.1
008A:  BCF    F93.1
008C:  NOP   
008E:  BSF    F93.0
0090:  BRA    0092
0092:  NOP   
0094:  BRA    0096
0096:  NOP   
0098:  BSF    F93.1
009A:  BTFSS  F81.1
009C:  BRA    009A
009E:  CLRF   01
00A0:  BRA    00A2
00A2:  NOP   
00A4:  BTFSC  F81.0
00A6:  BSF    01.0
00A8:  BCF    F8A.1
00AA:  BCF    F93.1
00AC:  BCF    F8A.0
00AE:  BCF    F93.0
00B0:  RETURN 0
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <functions.h> //Biblioteca auxiliar com todas as funções de comando 
.................... #include <I2C_LCD.c> //Biblioteca de controle do Display por I2C 
.................... // CCS C driver code for I2C LCDs (HD44780 compliant controllers) 
.................... // https://simple-circuit.com/ 
....................   
.................... #define LCD_BACKLIGHT          0x08 
.................... #define LCD_NOBACKLIGHT        0x00 
.................... #define LCD_FIRST_ROW          0x80 
.................... #define LCD_SECOND_ROW         0xC0 
.................... #define LCD_THIRD_ROW          0x94 
.................... #define LCD_FOURTH_ROW         0xD4 
.................... #define LCD_CLEAR              0x01 
.................... #define LCD_RETURN_HOME        0x02 
.................... #define LCD_ENTRY_MODE_SET     0x04 
.................... #define LCD_CURSOR_OFF         0x0C 
.................... #define LCD_UNDERLINE_ON       0x0E 
.................... #define LCD_BLINK_CURSOR_ON    0x0F 
.................... #define LCD_MOVE_CURSOR_LEFT   0x10 
.................... #define LCD_MOVE_CURSOR_RIGHT  0x14 
.................... #define LCD_TURN_ON            0x0C 
.................... #define LCD_TURN_OFF           0x08 
.................... #define LCD_SHIFT_LEFT         0x18 
.................... #define LCD_SHIFT_RIGHT        0x1E 
....................   
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................   
....................   
.................... int1 RS; 
.................... unsigned int8 i2c_addr, backlight_val = LCD_BACKLIGHT; 
....................   
.................... void LCD_Write_Nibble(unsigned int8 n); 
.................... void LCD_Cmd(unsigned int8 Command); 
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row); 
.................... void LCD_Out(unsigned int8 LCD_Char); 
.................... void LCD_Begin(unsigned int8 _i2c_addr); 
.................... void Backlight(); 
.................... void noBacklight(); 
.................... void Expander_Write(unsigned int8 value); 
....................   
.................... void LCD_Write_Nibble(unsigned int8 n) { 
....................   n |= RS; 
*
0112:  MOVLW  00
0114:  BTFSC  06.0
0116:  MOVLW  01
0118:  IORWF  0C,F
....................   Expander_Write(n); 
011A:  MOVFF  0C,0E
011E:  RCALL  00B2
....................   Expander_Write(n | 0x04); 
0120:  MOVF   0C,W
0122:  IORLW  04
0124:  MOVWF  0D
0126:  MOVWF  0E
0128:  RCALL  00B2
....................   delay_us(1); 
012A:  BRA    012C
....................   Expander_Write(n & 0xFB); 
012C:  MOVF   0C,W
012E:  ANDLW  FB
0130:  MOVWF  0D
0132:  MOVWF  0E
0134:  RCALL  00B2
....................   delay_us(50); 
0136:  MOVLW  20
0138:  MOVWF  00
013A:  DECFSZ 00,F
013C:  BRA    013A
013E:  BRA    0140
0140:  NOP   
0142:  RETURN 0
.................... } 
....................   
.................... void LCD_Cmd(unsigned int8 Command) { 
....................   RS = 0; 
0144:  BCF    06.0
....................   LCD_Write_Nibble(Command & 0xF0); 
0146:  MOVF   0A,W
0148:  ANDLW  F0
014A:  MOVWF  0B
014C:  MOVWF  0C
014E:  RCALL  0112
....................   LCD_Write_Nibble((Command << 4) & 0xF0); 
0150:  SWAPF  0A,W
0152:  MOVWF  00
0154:  MOVLW  F0
0156:  ANDWF  00,F
0158:  MOVF   00,W
015A:  ANDLW  F0
015C:  MOVWF  0B
015E:  MOVWF  0C
0160:  RCALL  0112
0162:  RETURN 0
.................... } 
....................   
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row) { 
....................   switch(row) { 
....................     case 2: 
....................       LCD_Cmd(0xC0 + col-1); 
....................       break; 
....................     case 3: 
....................       LCD_Cmd(0x94 + col-1); 
....................       break; 
....................     case 4: 
....................       LCD_Cmd(0xD4 + col-1); 
....................     break; 
....................     default:      // case 1: 
....................       LCD_Cmd(0x80 + col-1); 
....................   } 
.................... } 
....................   
.................... void LCD_Out(unsigned int8 LCD_Char){ 
....................   RS = 1; 
....................   LCD_Write_Nibble(LCD_Char & 0xF0); 
....................   LCD_Write_Nibble((LCD_Char << 4) & 0xF0); 
.................... } 
....................   
.................... void LCD_Begin(unsigned int8 _i2c_addr) { 
....................   i2c_addr = _i2c_addr; 
0164:  MOVFF  09,07
....................   Expander_Write(0); 
0168:  CLRF   0E
016A:  RCALL  00B2
....................   delay_ms(40); 
016C:  MOVLW  28
016E:  MOVWF  0B
0170:  RCALL  00EC
....................   LCD_Cmd(3); 
0172:  MOVLW  03
0174:  MOVWF  0A
0176:  RCALL  0144
....................   delay_ms(5); 
0178:  MOVLW  05
017A:  MOVWF  0B
017C:  RCALL  00EC
....................   LCD_Cmd(3); 
017E:  MOVLW  03
0180:  MOVWF  0A
0182:  RCALL  0144
....................   delay_ms(5); 
0184:  MOVLW  05
0186:  MOVWF  0B
0188:  RCALL  00EC
....................   LCD_Cmd(3); 
018A:  MOVLW  03
018C:  MOVWF  0A
018E:  RCALL  0144
....................   delay_ms(5); 
0190:  MOVLW  05
0192:  MOVWF  0B
0194:  RCALL  00EC
....................   LCD_Cmd(LCD_RETURN_HOME); 
0196:  MOVLW  02
0198:  MOVWF  0A
019A:  RCALL  0144
....................   delay_ms(5); 
019C:  MOVLW  05
019E:  MOVWF  0B
01A0:  RCALL  00EC
....................   LCD_Cmd(0x20 | (LCD_TYPE << 2)); 
01A2:  MOVLW  28
01A4:  MOVWF  0A
01A6:  RCALL  0144
....................   delay_ms(50); 
01A8:  MOVLW  32
01AA:  MOVWF  0B
01AC:  RCALL  00EC
....................   LCD_Cmd(LCD_TURN_ON); 
01AE:  MOVLW  0C
01B0:  MOVWF  0A
01B2:  RCALL  0144
....................   delay_ms(50); 
01B4:  MOVLW  32
01B6:  MOVWF  0B
01B8:  RCALL  00EC
....................   LCD_Cmd(LCD_CLEAR); 
01BA:  MOVLW  01
01BC:  MOVWF  0A
01BE:  RCALL  0144
....................   delay_ms(50); 
01C0:  MOVLW  32
01C2:  MOVWF  0B
01C4:  RCALL  00EC
....................   LCD_Cmd(LCD_ENTRY_MODE_SET | LCD_RETURN_HOME); 
01C6:  MOVLW  06
01C8:  MOVWF  0A
01CA:  RCALL  0144
....................   delay_ms(50); 
01CC:  MOVLW  32
01CE:  MOVWF  0B
01D0:  RCALL  00EC
01D2:  GOTO   0264 (RETURN)
.................... } 
....................   
.................... void Backlight() { 
....................   backlight_val = LCD_BACKLIGHT; 
....................   Expander_Write(0); 
.................... } 
....................   
.................... void noBacklight() { 
....................   backlight_val = LCD_NOBACKLIGHT; 
....................   Expander_Write(0); 
.................... } 
....................   
.................... void Expander_Write(unsigned int8 value) { 
....................   I2C_Start(I2C_LCD); 
*
00B2:  BSF    F93.0
00B4:  BRA    00B6
00B6:  BSF    F93.1
00B8:  BRA    00BA
00BA:  NOP   
00BC:  BCF    F8A.0
00BE:  BCF    F93.0
00C0:  BRA    00C2
00C2:  BCF    F8A.1
00C4:  BCF    F93.1
....................   I2C_Write(I2C_LCD, i2c_addr); 
00C6:  MOVFF  07,10
00CA:  RCALL  0062
....................   I2C_Write(I2C_LCD, value | backlight_val); 
00CC:  MOVF   0E,W
00CE:  IORWF  08,W
00D0:  MOVWF  0F
00D2:  MOVWF  10
00D4:  RCALL  0062
....................   I2C_Stop(I2C_LCD); 
00D6:  BCF    F93.0
00D8:  NOP   
00DA:  BSF    F93.1
00DC:  BTFSS  F81.1
00DE:  BRA    00DC
00E0:  BRA    00E2
00E2:  BRA    00E4
00E4:  NOP   
00E6:  BSF    F93.0
00E8:  BRA    00EA
00EA:  RETURN 0
.................... } 
....................  
.................... //Função para iniciar o display 
.................... void Start(){    
....................    //LCD_Goto(coluna, linha);         
....................    LCD_Goto(2, 2);                          
....................    LCD_Out("Carregando ."); 
....................    delay_ms(300); 
....................    LCD_Goto(14, 2); 
....................    LCD_Out(".");    
....................    delay_ms(300); 
....................    LCD_Goto(15, 2); 
....................    LCD_Out("."); 
....................    delay_ms(300); 
....................    LCD_Goto(16, 2); 
....................    LCD_Out("."); 
....................    delay_ms(300); 
....................    LCD_Goto(1, 2); 
....................    LCD_Out("                    ");                //Limpara o display    
....................    LCD_Goto(2, 2);                                // Go to column 2 row 3 
....................    LCD_Out("Clique em iniciar");  
.................... } 
....................  
.................... void CloseDoor(){ 
....................    LCD_Goto(2,2); 
....................    LCD_Out("                    ");                //Limpara o display    
....................    LCD_Goto(2,2); 
....................    LCD_Out("Fecha Porta"); 
.................... } 
....................  
.................... // Função de constrole do andar das lâmpadas ========================================== 
.................... void Lamps(){                                       
....................    unsigned int8 speed_ = 2000;                    //Velocidade dos motores 
....................     
....................    for(;;){                                        //Função para mover as lampadas 
....................       if(input(pin_B7)){                           //Teste para saber se está no final. Se não estiver ela irá para o ponto inicial          
....................          for(int i=0; i<3; i++){                   //irá para o meio da pagina para começar a esterilização             
....................             output_c(0b00000101); 
....................             delay_ms(speed_); 
....................             output_c(0b00000110); 
....................             delay_ms(speed_); 
....................             output_c(0b00010010); 
....................             delay_ms(speed_); 
....................             output_c(0b00010001); 
....................             delay_ms(speed_);         
....................          } 
....................          delay_ms(2000);                         //Tempo de espera de 40 segundos para esterelização   
....................          for(;;){                                //Função que retornará as lampadas para o estágio inicial             
....................             output_c(0b00000110); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00000101); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010001); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010010); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................          }    
....................          break; 
....................       }else{                                    //Caso não esteja na posição inicial essa função irá levar até la                
....................          for(;;){                   
....................             output_c(0b00000110); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break;            //Teste se chegou na posição inicial 
....................             output_c(0b00000101); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010001); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................             output_c(0b00010010); 
....................             delay_ms(speed_); 
....................             if(input(pin_B7)) break; 
....................          } 
....................       } 
....................    }    
....................    delay_ms(2000);                              //Tempo de aguardo até passar as páginas 
.................... } 
....................  
.................... //Função que irá passar as páginas =============================================================== 
.................... void PassadorPag(){ 
*
01D6:  MOVLW  E8
01D8:  MOVWF  09
....................    unsigned int8 speed_ = 1000;           //Velocidade dos motores 
....................    /*LCD_Goto(2, 2);   
....................    LCD_Out("                    ");                //Limpara o display 
....................    LCD_Goto(2, 2);   
....................    LCD_Out("Passando pagina");  
....................    for(;;){                               //Haste principal irá para a frente até encostar no livro 
....................       output_a(0b00000110); 
....................       delay_ms(speed_); 
....................       if(input(pin_B3)) break;            //Teste se encostou no livro 
....................       output_a(0b00000101); 
....................       delay_ms(speed_); 
....................       if(input(pin_B3)) break; 
....................       output_a(0b00001001); 
....................       delay_ms(speed_); 
....................       if(input(pin_B3)) break; 
....................       output_a(0b00001010); 
....................       delay_ms(speed_); 
....................       if(input(pin_B3)) break; 
....................    } 
....................    delay_ms(500); 
....................    output_high(pin_B2);                    //Liga o FAN para segurar a página 
....................    delay_ms(1000);                        //Depois que tiver encostador irá parar e esperar até sugar a página 
....................    for(;;){                               //Irá passar a pagina até encostar do outro lado 
....................       output_a(0b00000101); 
....................       delay_ms(speed_); 
....................       if(input(pin_B4)) break;            //Teste se chegou do outro lado 
....................       output_a(0b00000110); 
....................       delay_ms(speed_); 
....................       if(input(pin_B4)) break; 
....................       output_a(0b00001010); 
....................       delay_ms(speed_); 
....................       if(input(pin_B4)) break; 
....................       output_a(0b00001001); 
....................       delay_ms(speed_);        
....................       if(input(pin_B4)) break; 
....................    } 
....................    delay_ms(1000);                         
....................    output_low(pin_B2);                    //Desliga a FAN do Passador 
....................    delay_ms(1000);  */  
....................                                  //Faz a haste secundária sair da pagina 
....................    output_d(0b00000001); 
01DA:  MOVLW  01
01DC:  MOVWF  F8C
....................    delay_ms(speed_); 
01DE:  MOVFF  09,0B
01E2:  RCALL  00EC
....................    output_d(0b00000011); 
01E4:  MOVLW  03
01E6:  MOVWF  F8C
....................    delay_ms(speed_); 
01E8:  MOVFF  09,0B
01EC:  RCALL  00EC
....................    output_d(0b00000010); 
01EE:  MOVLW  02
01F0:  MOVWF  F8C
....................    delay_ms(2000);   
01F2:  MOVLW  08
01F4:  MOVWF  0A
01F6:  MOVLW  FA
01F8:  MOVWF  0B
01FA:  RCALL  00EC
01FC:  DECFSZ 0A,F
01FE:  BRA    01F6
....................    //Faz a Haste primaria ficar na vertical 
....................    output_a(0b00000110); 
0200:  CLRF   F92
0202:  MOVLW  06
0204:  MOVWF  F89
....................    delay_ms(speed_);    
0206:  MOVFF  09,0B
020A:  RCALL  00EC
....................    output_a(0b00000101); 
020C:  CLRF   F92
020E:  MOVLW  05
0210:  MOVWF  F89
....................    delay_ms(speed_); 
0212:  MOVFF  09,0B
0216:  RCALL  00EC
....................    //Faz a haste secudária voltar para a posição original 
....................    output_d(0b00000011);       
0218:  MOVLW  03
021A:  MOVWF  F8C
....................    delay_ms(speed_); 
021C:  MOVFF  09,0B
0220:  RCALL  00EC
....................    output_d(0b00000001); 
0222:  MOVLW  01
0224:  MOVWF  F8C
....................    delay_ms(speed_);         
0226:  MOVFF  09,0B
022A:  RCALL  00EC
022C:  GOTO   026E (RETURN)
....................  
....................        
.................... } 
....................  
....................  
....................  
....................  
.................... void main() 
0230:  CLRF   FF8
0232:  BCF    FD0.7
0234:  MOVLW  70
0236:  MOVWF  FD3
0238:  MOVF   FD3,W
023A:  MOVLW  08
023C:  MOVWF  08
023E:  MOVF   FC1,W
0240:  ANDLW  C0
0242:  IORLW  0F
0244:  MOVWF  FC1
0246:  MOVLW  07
0248:  MOVWF  FB4
024A:  CLRF   04
024C:  CLRF   05
.................... { 
....................    output_b(0);     
024E:  CLRF   F8A
....................    output_d(0);  
0250:  CLRF   F8C
....................    output_c(0);  
0252:  CLRF   F8B
....................    set_tris_b(0b1111000); //setando as portas como 1=input || 0=output 
0254:  MOVLW  78
0256:  MOVWF  F93
....................    set_tris_c(0);  
0258:  MOVLW  00
025A:  MOVWF  F94
....................    set_tris_d(0);  
025C:  MOVWF  F95
....................    LCD_Begin(0x4E);  
025E:  MOVLW  4E
0260:  MOVWF  09
0262:  BRA    0164
....................    //Start(); 
....................    while(TRUE){ 
....................       if(input(pin_B5)){          
0264:  BTFSS  F81.5
0266:  BRA    026E
....................          if(input(pin_B6)){                  
0268:  BTFSS  F81.6
026A:  BRA    026E
....................                //LCD_Goto(2,2); 
....................                //LCD_Out("                    ");                //Limpara o display                
....................                //LCD_Goto(2,2); 
....................                //LCD_Out("Iniciado"); 
....................                //Lamps(); 
....................                PassadorPag(); 
026C:  BRA    01D6
....................          }else{                                               //Teste para as portas fechadas  
....................                                            
....................          } 
....................       } 
....................       delay_ms(200); 
026E:  MOVLW  C8
0270:  MOVWF  0B
0272:  RCALL  00EC
0274:  BRA    0264
....................    } 
.................... } 
....................  
0276:  SLEEP 
....................  

Configuration Fuses:
   Word  1: C83F   PLL12 CPUDIV4 USBDIV INTRC_IO FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
